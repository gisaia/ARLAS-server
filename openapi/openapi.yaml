openapi: 3.0.1
info:
  title: ARLAS Server APIs
  description: Explore the content of ARLAS collections
  contact:
    name: Gisaia
    url: http://www.gisaia.com/
    email: contact@gisaia.com
  license:
    name: Apache 2.0
    url: https://www.apache.org/licenses/LICENSE-2.0.html
  version: API_VERSION
externalDocs:
  description: API documentation
  url: https://docs.arlas.io/arlas-api/
servers:
- url: /arlas
  description: default server
tags:
- name: collections
  description: Collections API
- name: explore
  description: Explore API
paths:
  /collections/{collection}:
    get:
      tags:
      - collections
      summary: Get a collection reference
      description: Get a collection reference in ARLAS
      operationId: get
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/CollectionReference'
        "404":
          description: Collection not found.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
    put:
      tags:
      - collections
      summary: Add a collection reference
      description: Add a collection reference in ARLAS
      operationId: put
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: checkfields
        in: query
        schema:
          type: boolean
          default: true
      requestBody:
        description: collectionParams
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/CollectionReferenceParameters'
        required: true
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/CollectionReference'
        "400":
          description: JSON parameter malformed.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "404":
          description: Not Found Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
    delete:
      tags:
      - collections
      summary: Delete a collection reference
      description: Delete a collection reference in ARLAS
      operationId: delete
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Success'
        "404":
          description: Collection not found.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /collections/_export:
    get:
      tags:
      - collections
      summary: Get all collection references as a json file
      description: Get all collection references in ARLAS as json file
      operationId: exportCollections
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/CollectionReference'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /collections:
    get:
      tags:
      - collections
      summary: Get all collection references
      description: Get all collection references in ARLAS
      operationId: getAll
      parameters:
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/CollectionReference'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /collections/_import:
    post:
      tags:
      - collections
      summary: Add collection references from a json file
      description: Add collection references in ARLAS from a json file
      operationId: importCollections
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  $ref: '#/components/schemas/FormDataContentDisposition'
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: string
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /collections/{collection}/organisations:
    patch:
      tags:
      - collections
      summary: Update a collection reference's organisations attribute.
      description: Update a collection reference's organisations attribute.
      operationId: patch
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      requestBody:
        description: collectionParamsUpdate
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/CollectionReferenceUpdate'
        required: true
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/CollectionReference'
        "400":
          description: JSON parameter malformed.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "404":
          description: Collection not found.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_aggregate:
    get:
      tags:
      - explore
      summary: Aggregate
      description: "Aggregate the elements in the collection(s), given the filters\
        \ and the aggregation parameters"
      operationId: aggregate
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: agg
        in: query
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:fetch_hits-{fetch_hits\
          \ values} \n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram, geotile and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types. \n \n   - It's possible\
          \ to apply multiple metric aggregations by defining multiple (**collect_field**,**collect_fct**)\
          \ couples.\n \n   - (**collect_field**,**collect_fct**) couples should be\
          \ unique in that case.\n \n   - (**order**,**on**) couple is optional for\
          \ all aggregation types.\n \n   - **size** is optional for term and geohash/geotile,\
          \ and must not be specified for the other types.\n \n   - **include** is\
          \ optional for term, and must not be specified for the other types.\n \n\
          - {type} possible values are : \n \n       datehistogram, histogram, geohash,\
          \ geotile and term. \n \n- {interval} possible values depends on {type}.\
          \ \n \n       If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = geotile, then {interval} = {size}. It's an integer\
          \ corresponding to zoom level of the aggregation, that should be larger\
          \ than or equal to {z} in the path param, and no bigger than {z}+6. \n \n\
          \       If {type} = term, then interval-{interval} is not needed. \n \n\
          - format-{format} is the date format for key aggregation. The default value\
          \ is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum\n \n- {order}\
          \ is set to sort the aggregation buckets on the field name, on the count\
          \ of the buckets or on the the result of a metric sub-aggregation. Its values\
          \ are 'asc' or 'desc'. \n \n- {on} is set to specify whether the {order}\
          \ is on the field name, on the count of the aggregation or on the result\
          \ of a metric sub-aggregation. Its values are 'field', 'count' or 'result'.\
          \ \n \n- If {on} is equal to `result` and two or more (**collect_field**,**collect_fct**)\
          \ couples are specified, then the order is applied on the first `collect_fct`\
          \ that is different from geobbox and geocentroid\n \n- {size} Defines how\
          \ many buckets should be returned. \n \n- {include} Specifies the values\
          \ for which buckets will be created. This values are comma separated. If\
          \ one value is specified then regular expressions can be used (only in this\
          \ case) and buckets matching them will be created. If more than one value\
          \ are specified then only buckets matching the exact values will be created.\n\
          \ \n- **aggregated_geometries**\n \n    > **What it does**: Allows to specify\
          \ a list of aggregated forms of geometries that represent the bucket.\n\
          \ \n    > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.\n\
          \ \n    > __**Available aggregated geometries**__: `centroid, bbox, cell,\
          \ cell_center`.\n \n       - **centroid**: returns the centroid of data\
          \ inside the bucket.\n \n       - **bbox**: returns the data extent (bbox)\
          \ in each bucket.\n \n       - **cell**: returns the cell extent (zxy or\
          \ geohash) of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n       - **cell_center**: returns the cell\
          \ center of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n    > __**Response**__: the aggregated geometries\
          \ are returned in `geometries` list in the json response. Each object inside\
          \ this list has : the reference to the aggregated form, the geojson geometry\
          \ and an attribute `is_raw` set to false\n \n    > __**Example**__: `aggregated_geometries-bbox,cell`\n\
          \ \n- **raw_geometries**\n \n    > **What it does**: Allows to specify a\
          \ list of raw geometries provided by hits that represent the bucket and\
          \ that are elected by a sort\n \n    > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.\n\
          \ \n    > __**Available raw geometries**__: any field of the collection\
          \ whose type is **geo-point** or **geo-shape**.\n \n       - sort fields\
          \ are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path`\
          \ is applied\n \n       - a sort field can be preceded by '-' for descending\
          \ sort. Otherwise the sort is ascending\n \n    > __**Response**__: the\
          \ aggregated geometries are returned in `geometries` list in the json response.\
          \ Each object inside this list has : the reference to the geometry path,\
          \ the used sort, the geojson geometry and an attribute `is_raw` set to true\n\
          \ \n    > __**Example**__: `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)`\
          \ || raw_geometries-geo_field1(field1);geo_field2(field2,field3)\n \n- **fetch_hits**\
          \ \n \n    > **What it does**: Specifies the number of hits to retrieve\
          \ inside each aggregation bucket and which fields to include in the hits.\n\
          \ \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2},\
          \ -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional,\
          \ if not specified, 1 is considered as default.\n \n    > **Note 2**: `{field}`\
          \ can be preceded by **+** or **-** for **ascending** or **descending**\
          \ sort of the hits. Order matters.\n \n    > __**Example**__: `fetch_hits-3(-timestamp,\
          \ geometry)`. Fetches the 3 last positions for each bucket.\n \n**agg**\
          \ parameter is multiple. Every agg parameter specified is a subaggregation\
          \ of the previous one : order matters. \n \nFor more details, check https://gitlab.com/GISAIA.ARLAS/ARLAS-server/blob/master/doc/api/API-definition.md."
        required: true
        schema:
          type: array
          items:
            type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: flat
        in: query
        description: "Flats the property map: only key/value on one level"
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/AggregationResponse'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
    post:
      tags:
      - explore
      summary: Aggregate
      description: "Aggregate the elements in the collection(s), given the filters\
        \ and the aggregation parameters"
      operationId: aggregatePost
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      requestBody:
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/AggregationsRequest'
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/AggregationResponse'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_geoaggregate:
    get:
      tags:
      - explore
      summary: GeoAggregate
      description: "Aggregate the elements in the collection(s) as features, given\
        \ the filters and the aggregation parameters."
      operationId: geoaggregate
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: agg
        in: query
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:raw_geometries-{raw_geometries\
          \ values}:aggregated_geometries-{aggregated_geometries values}:fetch_hits-{fetch_hits\
          \ values}\n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram, geotile and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types.\n \n   - (**order**,**on**)\
          \ couple is optional for all aggregation types.\n \n   - **size** is optional\
          \ for term and geohash/geotile, and must not be specified for the other\
          \ types.\n \n   - **include** is optional for term, and must not be specified\
          \ for the other types.\n \n- {type} possible values are : \n \n       geohash,\
          \ geotile, datehistogram, histogram and term. geohash or geotile must be\
          \ the main aggregation.\n \n- {interval} possible values depends on {type}.\
          \ \n \n       If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = geotile, then {interval} = {size}. It's an integer\
          \ corresponding to zoom level of the aggregation, that should be larger\
          \ than or equal to {z} in the path param, and no bigger than {z}+6 (max\
          \ 29). \n \n       If {type} = term, then interval-{interval} is not needed.\
          \ \n \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum,geobbox,geocentroid\n\
          \ \n- (collect_field,collect_fct) should both be specified, except when\
          \ collect_fct = `geobbox` or `geocentroid`, it could be specified alone.\
          \ The metrics `geobbox` and `geocentroid` are returned as features collections.\n\
          \ \n- {order} is set to sort the aggregation buckets on the field name,\
          \ on the count of the buckets or on the the result of a metric sub-aggregation.\
          \ Its values are 'asc' or 'desc'. \n \n- {on} is set to specify whether\
          \ the {order} is on the field name, on the count of the aggregation or on\
          \ the result of a metric sub-aggregation. Its values are 'field', 'count'\
          \ or 'result'. \n \n- When {on} = `result`, then (collect_field,collect_fct)\
          \ should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`,\
          \ then {on}=`result` is prohibited\n \n- {size} Defines how many buckets\
          \ should be returned. \n \n- {include} Specifies the values for which buckets\
          \ will be created. This values are comma separated. If one value is specified\
          \ then regular expressions can be used (only in this case) and buckets matching\
          \ them will be created. If more than one value are specified then only buckets\
          \ matching the exact values will be created.\n \n- **aggregated_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of aggregated forms\
          \ of geometries that represent the bucket.\n \n    > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.\n\
          \ \n    > __**Available aggregated geometries**__: `centroid, bbox, cell,\
          \ cell_center`.\n \n       - **centroid**: returns the centroid of data\
          \ inside the bucket.\n \n       - **bbox**: returns the data extent (bbox)\
          \ in each bucket.\n \n       - **cell**: returns the cell (zxy or geohash)\
          \ extent of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n       - **cell_center**: returns the cell\
          \ center of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n    > __**Response**__: Each bucket of the\
          \ aggregation will be represented with as many features (in a feature collection)\
          \ as there are specified aggregated geometries. The properties of each feature\
          \ has :\n \n       - **geometry_ref** attribute that informs which aggregated\
          \ form is returned \n \n       - **geometry_type** attribute set to *aggregated*\n\
          \ \n    > __**Example**__: `aggregated_geometries-bbox,geohash`\n \n- **raw_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of raw geometries provided\
          \ by hits that represent the bucket and that are elected by a sort\n \n\
          \    > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.\n\
          \ \n    > __**Available raw geometries**__: any field of the collection\
          \ whose type is **geo-point** or **geo-shape**.\n \n       - sort fields\
          \ are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path`\
          \ is applied\n \n       - a sort field can be preceded by '-' for descending\
          \ sort. Otherwise the sort is ascending\n \n    > __**Response**__: each\
          \ bucket of the aggregation will be represented with as many features (in\
          \ a feature collection) as there are specified raw geometries. The properties\
          \ of each feature has :\n \n       - **geometry_ref** attribute that informs\
          \ which geometry path is returned \n \n       - **geometry_type** attribute\
          \ set to *raw*\n \n       - **geometry_sort** attribute that informs how\
          \ the geometry path is fetched (with what sort)\n \n    > __**Example**__:\
          \ `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)`\
          \ || raw_geometries-geo_field1(field1);geo_field2(field2,field3)\n \n- **fetch_hits**\
          \ \n \n    > **What it does**: Specifies the number of hits to retrieve\
          \ inside each aggregation bucket and which fields to include in the hits.\n\
          \ \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2},\
          \ -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional,\
          \ if not specified, 1 is considered as default.\n \n    > **Note 2**: `{field}`\
          \ can be preceded by **+** or **-** for **ascending** or **descending**\
          \ sort of the hits. Order matters.\n \n    > __**Example**__: `fetch_hits-3(-timestamp,\
          \ geometry)`. Fetches the 3 last positions for each bucket.\n \n**agg**\
          \ parameter is multiple. The first (main) aggregation must be geohash or\
          \ geotile. Every agg parameter specified is a subaggregation of the previous\
          \ one : order matters. \n \nFor more details, check https://github.com/gisaia/ARLAS-server/blob/master/docs/arlas-api-exploration.md "
        required: true
        schema:
          type: array
          items:
            type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: flat
        in: query
        description: "Flats the property map: only key/value on one level"
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/FeatureCollection'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "501":
          description: Not implemented functionality.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
    post:
      tags:
      - explore
      summary: GeoAggregate
      description: "Aggregate the elements in the collection(s) as features, given\
        \ the filters and the aggregation parameters."
      operationId: geoaggregatePost
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      requestBody:
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/AggregationsRequest'
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/FeatureCollection'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "501":
          description: Not implemented functionality.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_geoaggregate/{geohash}:
    get:
      tags:
      - explore
      summary: GeoAggregate on a geohash
      description: "Aggregate the elements in the collection(s) and localized in the\
        \ given geohash as features, given the filters and the aggregation parameters."
      operationId: geohashgeoaggregate
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: geohash
        in: path
        description: geohash
        required: true
        schema:
          type: string
      - name: agg
        in: query
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:raw_geometries-{raw_geometries\
          \ values}:aggregated_geometries-{aggregated_geometries values}:fetch_hits-{fetch_hits\
          \ values}\n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram, geotile and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types.\n \n   - (**order**,**on**)\
          \ couple is optional for all aggregation types.\n \n   - **size** is optional\
          \ for term and geohash/geotile, and must not be specified for the other\
          \ types.\n \n   - **include** is optional for term, and must not be specified\
          \ for the other types.\n \n- {type} possible values are : \n \n       geohash,\
          \ geotile, datehistogram, histogram and term. geohash or geotile must be\
          \ the main aggregation.\n \n- {interval} possible values depends on {type}.\
          \ \n \n       If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = geotile, then {interval} = {size}. It's an integer\
          \ corresponding to zoom level of the aggregation, that should be larger\
          \ than or equal to {z} in the path param, and no bigger than {z}+6 (max\
          \ 29). \n \n       If {type} = term, then interval-{interval} is not needed.\
          \ \n \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum,geobbox,geocentroid\n\
          \ \n- (collect_field,collect_fct) should both be specified, except when\
          \ collect_fct = `geobbox` or `geocentroid`, it could be specified alone.\
          \ The metrics `geobbox` and `geocentroid` are returned as features collections.\n\
          \ \n- {order} is set to sort the aggregation buckets on the field name,\
          \ on the count of the buckets or on the the result of a metric sub-aggregation.\
          \ Its values are 'asc' or 'desc'. \n \n- {on} is set to specify whether\
          \ the {order} is on the field name, on the count of the aggregation or on\
          \ the result of a metric sub-aggregation. Its values are 'field', 'count'\
          \ or 'result'. \n \n- When {on} = `result`, then (collect_field,collect_fct)\
          \ should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`,\
          \ then {on}=`result` is prohibited\n \n- {size} Defines how many buckets\
          \ should be returned. \n \n- {include} Specifies the values for which buckets\
          \ will be created. This values are comma separated. If one value is specified\
          \ then regular expressions can be used (only in this case) and buckets matching\
          \ them will be created. If more than one value are specified then only buckets\
          \ matching the exact values will be created.\n \n- **aggregated_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of aggregated forms\
          \ of geometries that represent the bucket.\n \n    > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.\n\
          \ \n    > __**Available aggregated geometries**__: `centroid, bbox, cell,\
          \ cell_center`.\n \n       - **centroid**: returns the centroid of data\
          \ inside the bucket.\n \n       - **bbox**: returns the data extent (bbox)\
          \ in each bucket.\n \n       - **cell**: returns the cell (zxy or geohash)\
          \ extent of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n       - **cell_center**: returns the cell\
          \ center of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n    > __**Response**__: Each bucket of the\
          \ aggregation will be represented with as many features (in a feature collection)\
          \ as there are specified aggregated geometries. The properties of each feature\
          \ has :\n \n       - **geometry_ref** attribute that informs which aggregated\
          \ form is returned \n \n       - **geometry_type** attribute set to *aggregated*\n\
          \ \n    > __**Example**__: `aggregated_geometries-bbox,geohash`\n \n- **raw_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of raw geometries provided\
          \ by hits that represent the bucket and that are elected by a sort\n \n\
          \    > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.\n\
          \ \n    > __**Available raw geometries**__: any field of the collection\
          \ whose type is **geo-point** or **geo-shape**.\n \n       - sort fields\
          \ are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path`\
          \ is applied\n \n       - a sort field can be preceded by '-' for descending\
          \ sort. Otherwise the sort is ascending\n \n    > __**Response**__: each\
          \ bucket of the aggregation will be represented with as many features (in\
          \ a feature collection) as there are specified raw geometries. The properties\
          \ of each feature has :\n \n       - **geometry_ref** attribute that informs\
          \ which geometry path is returned \n \n       - **geometry_type** attribute\
          \ set to *raw*\n \n       - **geometry_sort** attribute that informs how\
          \ the geometry path is fetched (with what sort)\n \n    > __**Example**__:\
          \ `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)`\
          \ || raw_geometries-geo_field1(field1);geo_field2(field2,field3)\n \n- **fetch_hits**\
          \ \n \n    > **What it does**: Specifies the number of hits to retrieve\
          \ inside each aggregation bucket and which fields to include in the hits.\n\
          \ \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2},\
          \ -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional,\
          \ if not specified, 1 is considered as default.\n \n    > **Note 2**: `{field}`\
          \ can be preceded by **+** or **-** for **ascending** or **descending**\
          \ sort of the hits. Order matters.\n \n    > __**Example**__: `fetch_hits-3(-timestamp,\
          \ geometry)`. Fetches the 3 last positions for each bucket.\n \n**agg**\
          \ parameter is multiple. The first (main) aggregation must be geohash or\
          \ geotile. Every agg parameter specified is a subaggregation of the previous\
          \ one : order matters. \n \nFor more details, check https://github.com/gisaia/ARLAS-server/blob/master/docs/arlas-api-exploration.md "
        schema:
          type: array
          items:
            type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: flat
        in: query
        description: "Flats the property map: only key/value on one level"
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/FeatureCollection'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "501":
          description: Not implemented functionality.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_geoaggregate/{z}/{x}/{y}:
    get:
      tags:
      - explore
      summary: GeoAggregate on a geotile
      description: "Aggregate the elements in the collection(s) and localized in the\
        \ given tile as features, given the filters and the aggregation parameters."
      operationId: geotilegeoaggregate
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: z
        in: path
        description: z
        required: true
        schema:
          type: integer
          format: int32
      - name: x
        in: path
        description: x
        required: true
        schema:
          type: integer
          format: int32
      - name: "y"
        in: path
        description: "y"
        required: true
        schema:
          type: integer
          format: int32
      - name: agg
        in: query
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:raw_geometries-{raw_geometries\
          \ values}:aggregated_geometries-{aggregated_geometries values}:fetch_hits-{fetch_hits\
          \ values}\n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram, geotile and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types.\n \n   - (**order**,**on**)\
          \ couple is optional for all aggregation types.\n \n   - **size** is optional\
          \ for term and geohash/geotile, and must not be specified for the other\
          \ types.\n \n   - **include** is optional for term, and must not be specified\
          \ for the other types.\n \n- {type} possible values are : \n \n       geohash,\
          \ geotile, datehistogram, histogram and term. geohash or geotile must be\
          \ the main aggregation.\n \n- {interval} possible values depends on {type}.\
          \ \n \n       If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = geotile, then {interval} = {size}. It's an integer\
          \ corresponding to zoom level of the aggregation, that should be larger\
          \ than or equal to {z} in the path param, and no bigger than {z}+6 (max\
          \ 29). \n \n       If {type} = term, then interval-{interval} is not needed.\
          \ \n \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum,geobbox,geocentroid\n\
          \ \n- (collect_field,collect_fct) should both be specified, except when\
          \ collect_fct = `geobbox` or `geocentroid`, it could be specified alone.\
          \ The metrics `geobbox` and `geocentroid` are returned as features collections.\n\
          \ \n- {order} is set to sort the aggregation buckets on the field name,\
          \ on the count of the buckets or on the the result of a metric sub-aggregation.\
          \ Its values are 'asc' or 'desc'. \n \n- {on} is set to specify whether\
          \ the {order} is on the field name, on the count of the aggregation or on\
          \ the result of a metric sub-aggregation. Its values are 'field', 'count'\
          \ or 'result'. \n \n- When {on} = `result`, then (collect_field,collect_fct)\
          \ should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`,\
          \ then {on}=`result` is prohibited\n \n- {size} Defines how many buckets\
          \ should be returned. \n \n- {include} Specifies the values for which buckets\
          \ will be created. This values are comma separated. If one value is specified\
          \ then regular expressions can be used (only in this case) and buckets matching\
          \ them will be created. If more than one value are specified then only buckets\
          \ matching the exact values will be created.\n \n- **aggregated_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of aggregated forms\
          \ of geometries that represent the bucket.\n \n    > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.\n\
          \ \n    > __**Available aggregated geometries**__: `centroid, bbox, cell,\
          \ cell_center`.\n \n       - **centroid**: returns the centroid of data\
          \ inside the bucket.\n \n       - **bbox**: returns the data extent (bbox)\
          \ in each bucket.\n \n       - **cell**: returns the cell (zxy or geohash)\
          \ extent of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n       - **cell_center**: returns the cell\
          \ center of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n    > __**Response**__: Each bucket of the\
          \ aggregation will be represented with as many features (in a feature collection)\
          \ as there are specified aggregated geometries. The properties of each feature\
          \ has :\n \n       - **geometry_ref** attribute that informs which aggregated\
          \ form is returned \n \n       - **geometry_type** attribute set to *aggregated*\n\
          \ \n    > __**Example**__: `aggregated_geometries-bbox,geohash`\n \n- **raw_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of raw geometries provided\
          \ by hits that represent the bucket and that are elected by a sort\n \n\
          \    > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.\n\
          \ \n    > __**Available raw geometries**__: any field of the collection\
          \ whose type is **geo-point** or **geo-shape**.\n \n       - sort fields\
          \ are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path`\
          \ is applied\n \n       - a sort field can be preceded by '-' for descending\
          \ sort. Otherwise the sort is ascending\n \n    > __**Response**__: each\
          \ bucket of the aggregation will be represented with as many features (in\
          \ a feature collection) as there are specified raw geometries. The properties\
          \ of each feature has :\n \n       - **geometry_ref** attribute that informs\
          \ which geometry path is returned \n \n       - **geometry_type** attribute\
          \ set to *raw*\n \n       - **geometry_sort** attribute that informs how\
          \ the geometry path is fetched (with what sort)\n \n    > __**Example**__:\
          \ `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)`\
          \ || raw_geometries-geo_field1(field1);geo_field2(field2,field3)\n \n- **fetch_hits**\
          \ \n \n    > **What it does**: Specifies the number of hits to retrieve\
          \ inside each aggregation bucket and which fields to include in the hits.\n\
          \ \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2},\
          \ -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional,\
          \ if not specified, 1 is considered as default.\n \n    > **Note 2**: `{field}`\
          \ can be preceded by **+** or **-** for **ascending** or **descending**\
          \ sort of the hits. Order matters.\n \n    > __**Example**__: `fetch_hits-3(-timestamp,\
          \ geometry)`. Fetches the 3 last positions for each bucket.\n \n**agg**\
          \ parameter is multiple. The first (main) aggregation must be geohash or\
          \ geotile. Every agg parameter specified is a subaggregation of the previous\
          \ one : order matters. \n \nFor more details, check https://github.com/gisaia/ARLAS-server/blob/master/docs/arlas-api-exploration.md "
        schema:
          type: array
          items:
            type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: flat
        in: query
        description: "Flats the property map: only key/value on one level"
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/FeatureCollection'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "501":
          description: Not implemented functionality.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_shapeaggregate:
    get:
      tags:
      - explore
      summary: ShapeAggregate
      description: "Aggregate the elements in the collection(s) as features, given\
        \ the filters and the aggregation parameters, and returns a shapefile of it."
      operationId: shapeaggregate
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: agg
        in: query
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:raw_geometries-{raw_geometries\
          \ values}:aggregated_geometries-{aggregated_geometries values}:fetch_hits-{fetch_hits\
          \ values}\n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram, geotile and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types.\n \n   - (**order**,**on**)\
          \ couple is optional for all aggregation types.\n \n   - **size** is optional\
          \ for term and geohash/geotile, and must not be specified for the other\
          \ types.\n \n   - **include** is optional for term, and must not be specified\
          \ for the other types.\n \n- {type} possible values are : \n \n       geohash,\
          \ geotile, datehistogram, histogram and term. geohash or geotile must be\
          \ the main aggregation.\n \n- {interval} possible values depends on {type}.\
          \ \n \n       If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = geotile, then {interval} = {size}. It's an integer\
          \ corresponding to zoom level of the aggregation, that should be larger\
          \ than or equal to {z} in the path param, and no bigger than {z}+6 (max\
          \ 29). \n \n       If {type} = term, then interval-{interval} is not needed.\
          \ \n \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum,geobbox,geocentroid\n\
          \ \n- (collect_field,collect_fct) should both be specified, except when\
          \ collect_fct = `geobbox` or `geocentroid`, it could be specified alone.\
          \ The metrics `geobbox` and `geocentroid` are returned as features collections.\n\
          \ \n- {order} is set to sort the aggregation buckets on the field name,\
          \ on the count of the buckets or on the the result of a metric sub-aggregation.\
          \ Its values are 'asc' or 'desc'. \n \n- {on} is set to specify whether\
          \ the {order} is on the field name, on the count of the aggregation or on\
          \ the result of a metric sub-aggregation. Its values are 'field', 'count'\
          \ or 'result'. \n \n- When {on} = `result`, then (collect_field,collect_fct)\
          \ should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`,\
          \ then {on}=`result` is prohibited\n \n- {size} Defines how many buckets\
          \ should be returned. \n \n- {include} Specifies the values for which buckets\
          \ will be created. This values are comma separated. If one value is specified\
          \ then regular expressions can be used (only in this case) and buckets matching\
          \ them will be created. If more than one value are specified then only buckets\
          \ matching the exact values will be created.\n \n- **aggregated_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of aggregated forms\
          \ of geometries that represent the bucket.\n \n    > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.\n\
          \ \n    > __**Available aggregated geometries**__: `centroid, bbox, cell,\
          \ cell_center`.\n \n       - **centroid**: returns the centroid of data\
          \ inside the bucket.\n \n       - **bbox**: returns the data extent (bbox)\
          \ in each bucket.\n \n       - **cell**: returns the cell (zxy or geohash)\
          \ extent of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n       - **cell_center**: returns the cell\
          \ center of each bucket. This form is supported for **geohash** and **geotile**\
          \ aggregation type only.\n \n    > __**Response**__: Each bucket of the\
          \ aggregation will be represented with as many features (in a feature collection)\
          \ as there are specified aggregated geometries. The properties of each feature\
          \ has :\n \n       - **geometry_ref** attribute that informs which aggregated\
          \ form is returned \n \n       - **geometry_type** attribute set to *aggregated*\n\
          \ \n    > __**Example**__: `aggregated_geometries-bbox,geohash`\n \n- **raw_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of raw geometries provided\
          \ by hits that represent the bucket and that are elected by a sort\n \n\
          \    > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.\n\
          \ \n    > __**Available raw geometries**__: any field of the collection\
          \ whose type is **geo-point** or **geo-shape**.\n \n       - sort fields\
          \ are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path`\
          \ is applied\n \n       - a sort field can be preceded by '-' for descending\
          \ sort. Otherwise the sort is ascending\n \n    > __**Response**__: each\
          \ bucket of the aggregation will be represented with as many features (in\
          \ a feature collection) as there are specified raw geometries. The properties\
          \ of each feature has :\n \n       - **geometry_ref** attribute that informs\
          \ which geometry path is returned \n \n       - **geometry_type** attribute\
          \ set to *raw*\n \n       - **geometry_sort** attribute that informs how\
          \ the geometry path is fetched (with what sort)\n \n    > __**Example**__:\
          \ `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)`\
          \ || raw_geometries-geo_field1(field1);geo_field2(field2,field3)\n \n- **fetch_hits**\
          \ \n \n    > **What it does**: Specifies the number of hits to retrieve\
          \ inside each aggregation bucket and which fields to include in the hits.\n\
          \ \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2},\
          \ -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional,\
          \ if not specified, 1 is considered as default.\n \n    > **Note 2**: `{field}`\
          \ can be preceded by **+** or **-** for **ascending** or **descending**\
          \ sort of the hits. Order matters.\n \n    > __**Example**__: `fetch_hits-3(-timestamp,\
          \ geometry)`. Fetches the 3 last positions for each bucket.\n \n**agg**\
          \ parameter is multiple. The first (main) aggregation must be geohash or\
          \ geotile. Every agg parameter specified is a subaggregation of the previous\
          \ one : order matters. \n \nFor more details, check https://github.com/gisaia/ARLAS-server/blob/master/docs/arlas-api-exploration.md "
        required: true
        schema:
          type: array
          items:
            type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
        "500":
          description: Arlas Server Error.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
        "501":
          description: Not implemented functionality.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
    post:
      tags:
      - explore
      summary: ShapeAggregate
      description: "Aggregate the elements in the collection(s) as features, given\
        \ the filters and the aggregation parameters, and returns a shapefile of it."
      operationId: shapeaggregatePost
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      requestBody:
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/AggregationsRequest'
      responses:
        "200":
          description: Successful operation
        "500":
          description: Arlas Server Error.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
        "501":
          description: Not implemented functionality.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_compute:
    get:
      tags:
      - explore
      summary: Compute
      description: "Computes the given metric on a field in the collection, given\
        \ the filters"
      operationId: compute
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: field
        in: query
        description: The field on which the metric is calculated.
        required: true
        schema:
          type: string
      - name: metric
        in: query
        description: "The metric to compute : `max, min, avg, sum, cardinality, spanning,\
          \ geobbox, geocentroid`."
        required: true
        schema:
          type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/ComputationResponse'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
    post:
      tags:
      - explore
      summary: Compute
      description: "Computes the given metric on a field in the collection, given\
        \ the filters"
      operationId: computePost
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      requestBody:
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/ComputationRequest'
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/ComputationResponse'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_count:
    get:
      tags:
      - explore
      summary: Count
      description: "Count the number of elements found in the collection(s), given\
        \ the filters"
      operationId: count
      parameters:
      - name: collection
        in: path
        description: collections
        required: true
        schema:
          type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Hits'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
    post:
      tags:
      - explore
      summary: Count
      description: "Count the number of elements found in the collection(s), given\
        \ the filters"
      operationId: countPost
      parameters:
      - name: collection
        in: path
        description: collections
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      requestBody:
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/Count'
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Hits'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_describe:
    get:
      tags:
      - explore
      summary: Describe
      description: Describe the structure and the content of the given collection.
      operationId: describe
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/CollectionReferenceDescription'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "403":
          description: Collection not authorized.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/_list:
    get:
      tags:
      - explore
      summary: List
      description: List the collections configured in ARLAS.
      operationId: list
      parameters:
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/CollectionReferenceDescription'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "403":
          description: Collection not authorized.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/{identifier}:
    get:
      tags:
      - explore
      summary: Get an Arlas document
      description: Returns a raw indexed document.
      operationId: getArlasHit
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: identifier
        in: path
        description: identifier
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: flat
        in: query
        description: "Flats the property map: only key/value on one level"
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/ArlasHit'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "404":
          description: Not Found Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_geosearch:
    get:
      tags:
      - explore
      summary: GeoSearch
      description: "Search and return the elements found in the collection(s) as features,\
        \ given the filters"
      operationId: geosearch
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: flat
        in: query
        description: "Flats the property map: only key/value on one level"
        schema:
          type: boolean
          default: false
      - name: include
        in: query
        description: List the name patterns of the field to be included in the result.
          Separate patterns with a comma.
        style: form
        schema:
          type: string
          default: '*'
      - name: exclude
        in: query
        description: List the name patterns of the field to be excluded in the result.
          Separate patterns with a comma.
        style: form
        schema:
          type: string
      - name: returned_geometries
        in: query
        description: "Comma separated geometry field_paths to be included in the result.\
          \ If not specified, only geometry_path is returned. If geometry_path is\
          \ null, then centroid_path is returned"
        schema:
          type: string
      - name: size
        in: query
        description: The maximum number of entries or sub-entries to be returned.
          The default value is 10
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 10
      - name: from
        in: query
        description: From index to start the search from. Defaults to 0.
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 0
      - name: sort
        in: query
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        style: form
        schema:
          type: string
      - name: after
        in: query
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        schema:
          type: string
      - name: before
        in: query
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        schema:
          type: string
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/FeatureCollection'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
    post:
      tags:
      - explore
      summary: GeoSearch
      description: "Search and return the elements found in the collection(s) as features,\
        \ given the filters"
      operationId: geosearchPost
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      requestBody:
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/Search'
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/FeatureCollection'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_shapesearch:
    get:
      tags:
      - explore
      summary: ShapeSearch
      description: "Search and return the elements found in the collection(s) as features,\
        \ given the filters, exported as a Shapefile"
      operationId: shapesearch
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: include
        in: query
        description: List the name patterns of the field to be included in the result.
          Separate patterns with a comma.
        style: form
        schema:
          type: string
          default: '*'
      - name: exclude
        in: query
        description: List the name patterns of the field to be excluded in the result.
          Separate patterns with a comma.
        style: form
        schema:
          type: string
      - name: returned_geometries
        in: query
        description: "Comma separated geometry field_paths to be included in the result.\
          \ If not specified, only geometry_path is returned. If geometry_path is\
          \ null, then centroid_path is returned"
        schema:
          type: string
      - name: size
        in: query
        description: The maximum number of entries or sub-entries to be returned.
          The default value is 10
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 10
      - name: from
        in: query
        description: From index to start the search from. Defaults to 0.
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 0
      - name: sort
        in: query
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        style: form
        schema:
          type: string
      - name: after
        in: query
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        schema:
          type: string
      - name: before
        in: query
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        schema:
          type: string
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
        "500":
          description: Arlas Server Error.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
    post:
      tags:
      - explore
      summary: ShapeSearch
      description: "Search and return the elements found in the collection(s) as features,\
        \ given the filters, exported as a Shapefile"
      operationId: shapesearchPost
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      requestBody:
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/Search'
      responses:
        "200":
          description: Successful operation
        "500":
          description: Arlas Server Error.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/zip:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_geosearch/{z}/{x}/{y}:
    get:
      tags:
      - explore
      summary: Tiled GeoSearch
      description: "Search and return the elements found in the collection(s) and\
        \ localized in the given tile(x,y,z) as features, given the filters"
      operationId: tiledgeosearch
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: x
        in: path
        description: x
        required: true
        schema:
          type: integer
          format: int32
      - name: "y"
        in: path
        description: "y"
        required: true
        schema:
          type: integer
          format: int32
      - name: z
        in: path
        description: z
        required: true
        schema:
          type: integer
          format: int32
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: flat
        in: query
        description: "Flats the property map: only key/value on one level"
        schema:
          type: boolean
          default: false
      - name: include
        in: query
        description: List the name patterns of the field to be included in the result.
          Separate patterns with a comma.
        style: form
        schema:
          type: string
          default: '*'
      - name: exclude
        in: query
        description: List the name patterns of the field to be excluded in the result.
          Separate patterns with a comma.
        style: form
        schema:
          type: string
      - name: returned_geometries
        in: query
        description: "Comma separated geometry field_paths to be included in the result.\
          \ If not specified, only geometry_path is returned. If geometry_path is\
          \ null, then centroid_path is returned"
        schema:
          type: string
      - name: size
        in: query
        description: The maximum number of entries or sub-entries to be returned.
          The default value is 10
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 10
      - name: from
        in: query
        description: From index to start the search from. Defaults to 0.
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 0
      - name: sort
        in: query
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        style: form
        schema:
          type: string
      - name: after
        in: query
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        schema:
          type: string
      - name: before
        in: query
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        schema:
          type: string
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/FeatureCollection'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collection}/_search:
    get:
      tags:
      - explore
      summary: Search
      description: "Search and return the elements found in the collection, given\
        \ the filters"
      operationId: search
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
          default: true
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: flat
        in: query
        description: "Flats the property map: only key/value on one level"
        schema:
          type: boolean
          default: false
      - name: include
        in: query
        description: List the name patterns of the field to be included in the result.
          Separate patterns with a comma.
        schema:
          type: string
          default: '*'
      - name: exclude
        in: query
        description: List the name patterns of the field to be excluded in the result.
          Separate patterns with a comma.
        schema:
          type: string
      - name: returned_geometries
        in: query
        description: "Comma separated geometry field_paths to be included in the result.\
          \ If not specified, only geometry_path is returned. If geometry_path is\
          \ null, then centroid_path is returned"
        schema:
          type: string
      - name: size
        in: query
        description: The maximum number of entries or sub-entries to be returned.
          The default value is 10
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 10
      - name: from
        in: query
        description: From index to start the search from. Defaults to 0.
        schema:
          minimum: 0
          type: integer
          format: int64
          default: 0
      - name: sort
        in: query
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        schema:
          type: string
      - name: after
        in: query
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        schema:
          type: string
      - name: before
        in: query
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        schema:
          type: string
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Hits'
            application/atom+xml:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Hits'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
            application/atom+xml:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
            application/atom+xml:
              schema:
                $ref: '#/components/schemas/Error'
    post:
      tags:
      - explore
      summary: Search
      description: "Search and return the elements found in the collection, given\
        \ the filters"
      operationId: searchPost
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      requestBody:
        content:
          application/json;charset=utf-8:
            schema:
              $ref: '#/components/schemas/Search'
      responses:
        "200":
          description: Successful operation
          content:
            application/json;charset=utf-8:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Hits'
        "500":
          description: Arlas Server Error.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            application/json;charset=utf-8:
              schema:
                $ref: '#/components/schemas/Error'
  /explore/{collections}/_suggest:
    get:
      tags:
      - explore
      summary: Suggest
      description: Suggest the the n (n=size) most relevant terms given the filters
      operationId: suggest
      parameters:
      - name: collections
        in: path
        description: "collections, comma separated"
        required: true
        schema:
          type: string
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided. The order does not matter. \n \n- A triplet is composed of a\
          \ field name, a comparison operator and a value. \n \n  The possible values\
          \ of the comparison operator are : \n \n       Operator   |            \
          \       Description                      | value type\n \n       :     \
          \     |  {fieldName} equals {value}                        | numeric or\
          \ strings \n \n       :gte:      |  {fieldName} is greater than or equal\
          \ to  {value}  | numeric \n \n       :gt:       |  {fieldName} is greater\
          \ than {value}               | numeric \n \n       :lte:      |  {fieldName}\
          \ is less than or equal to {value}      | numeric \n \n       :lt:     \
          \  |  {fieldName}  is less than {value}                 | numeric \n \n\n\
          \ \n- The AND operator is applied between filters having different fieldNames.\
          \ \n \n- The OR operator is applied on filters having the same fieldName.\
          \ \n \n- If the fieldName starts with - then a must not filter is used\n\
          \ \n- If the fieldName starts with - then a must not filter is used\n \n\
          For more details, check https://gitlab.com/GISAIA.ARLAS/ARLAS-server/blob/master/doc/api/API-definition.md "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: A full text search
        schema:
          type: string
      - name: pretty
        in: query
        description: Pretty print
        schema:
          type: boolean
          default: false
      - name: size
        in: query
        description: The maximum number of entries or sub-entries to be returned.
          The default value is 10
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 10
      - name: from
        in: query
        description: From index to start the search from. Defaults to 0.
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 0
      - name: field
        in: query
        description: Name of the field to be used for retrieving the most relevant
          terms
        schema:
          type: string
          default: _all
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
  /explore/{collection}/_tile/{z}/{x}/{y}.png:
    get:
      tags:
      - explore
      summary: Tiled GeoSearch
      description: "Search and return the elements found in the collection(s) and\
        \ localized in the given tile(x,y,z) as features, given the filters"
      operationId: tiledgeosearch_1
      parameters:
      - name: collection
        in: path
        description: collection
        required: true
        schema:
          type: string
      - name: x
        in: path
        description: x
        required: true
        schema:
          type: integer
          format: int32
      - name: "y"
        in: path
        description: "y"
        required: true
        schema:
          type: integer
          format: int32
      - name: z
        in: path
        description: z
        required: true
        schema:
          type: integer
          format: int32
      - name: f
        in: query
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator        --                   Description   \
          \                 -- value type\n \n       :eq:            -- {fieldName}\
          \ equals {comma separated values}. **OR** operation is applied for the specified\
          \ values -- numeric or strings \n \n       :ne:            -- {fieldName}\
          \ must not equal {comma separated values }. **AND** operation is applied\
          \ for the specified values -- numeric or strings \n \n       :like:    \
          \      -- {fieldName}  is like {value}                     -- numeric or\
          \ strings \n \n       :gte:           -- {fieldName} is greater than or\
          \ equal to  {value} -- numeric \n \n       :gt:            -- {fieldName}\
          \ is greater than {value}              -- numeric \n \n       :lte:    \
          \       -- {fieldName} is less than or equal to {value}     -- numeric \n\
          \ \n       :lt:            -- {fieldName}  is less than {value}        \
          \        -- numeric \n \n       :range:         -- {fieldName} is between\
          \ `{comma separated [min<max] values}`. **OR** operation is applied for\
          \ the specified ranges -- numeric or strings. If the field's type is date,\
          \ then min & max should be timestamps in millisecond or a Date expression\n\
          \ \n       :within:        -- {GeofieldName}` is within the `{given WKT\
          \ string or the given BBOX }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` \n \n       :notwithin:     -- {GeofieldName} is\
          \ not within the `{given WKT string or the given BBOX }` -- a WKT string\
          \ or the BBOX string : `\"west, south, east, north\"` \n \n       :intersects:\
          \    -- {GeofieldName} intersects the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :notintersects: -- {GeofieldName} does not intersect the `{given\
          \ WKT string or the given }` -- a WKT string or the BBOX string : `\"west,\
          \ south, east, north\"` "
        style: form
        schema:
          type: array
          items:
            type: string
      - name: q
        in: query
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        style: form
        schema:
          type: array
          items:
            type: string
      - name: dateformat
        in: query
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        schema:
          type: string
      - name: righthand
        in: query
        description: "If righthand = true, the passed WKT should be counter clock-wise;\
          \ otherwise, ARLAS-server will attempt to parse it as the \"Complementary\"\
          \ Polygon on the other facet of the planet. \n Inversely, If righthand =\
          \ false, the passed WKT should be clock-wise; otherwise, ARLAS-server will\
          \ attempt to parse it as the \"Complementary\" Polygon on the other facet\
          \ of the planet. "
        schema:
          type: boolean
      - name: size
        in: query
        description: The maximum number of entries or sub-entries to be returned.
          The default value is 10
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 10
      - name: from
        in: query
        description: From index to start the search from. Defaults to 0.
        schema:
          minimum: 1
          type: integer
          format: int64
          default: 0
      - name: sort
        in: query
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        style: form
        schema:
          type: string
      - name: after
        in: query
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        schema:
          type: string
      - name: before
        in: query
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        schema:
          type: string
      - name: sampling
        in: query
        description: "Size of the sampling for testing transparency: 1: test every\
          \ pixel, 10: test 1 pixel every 10 pixels, etc."
        schema:
          type: integer
          format: int32
          default: 10
      - name: coverage
        in: query
        description: "Percentage (]0-100]) of acceptable transparent pixels. Higher\
          \ the percentage, more tiles could be used for filling the tile"
        schema:
          type: integer
          format: int32
          default: 70
      - name: max-age-cache
        in: query
        description: max-age-cache
        schema:
          type: integer
          format: int32
      responses:
        "200":
          description: Successful operation
        "500":
          description: Arlas Server Error.
          content:
            image/png:
              schema:
                $ref: '#/components/schemas/Error'
        "400":
          description: Bad request.
          content:
            image/png:
              schema:
                $ref: '#/components/schemas/Error'
components:
  schemas:
    Success:
      type: object
      properties:
        status:
          type: integer
          format: int32
        message:
          type: string
    Error:
      type: object
      properties:
        status:
          type: integer
          format: int32
        message:
          type: string
        error:
          type: string
    Bbox:
      required:
      - east
      - north
      - south
      - west
      type: object
      properties:
        north:
          type: number
          format: double
        south:
          type: number
          format: double
        east:
          type: number
          format: double
        west:
          type: number
          format: double
    CollectionDisplayNames:
      type: object
      properties:
        collection:
          type: string
        fields:
          type: object
          additionalProperties:
            type: string
        shape_columns:
          type: object
          additionalProperties:
            type: string
    CollectionOrganisations:
      type: object
      properties:
        owner:
          type: string
        shared:
          type: array
          items:
            type: string
        public:
          type: boolean
    CollectionReference:
      required:
      - collection_name
      - params
      type: object
      properties:
        collection_name:
          type: string
        params:
          $ref: '#/components/schemas/CollectionReferenceParameters'
    CollectionReferenceParameters:
      required:
      - centroid_path
      - geometry_path
      - id_path
      - index_name
      - timestamp_path
      type: object
      properties:
        index_name:
          type: string
        id_path:
          type: string
        geometry_path:
          type: string
        centroid_path:
          type: string
        timestamp_path:
          type: string
        exclude_fields:
          type: string
        update_max_hits:
          type: integer
          format: int32
        taggable_fields:
          type: string
        exclude_wfs_fields:
          type: string
        custom_params:
          type: object
          additionalProperties:
            type: string
        display_names:
          $ref: '#/components/schemas/CollectionDisplayNames'
        organisations:
          $ref: '#/components/schemas/CollectionOrganisations'
        atom_feed:
          $ref: '#/components/schemas/Feed'
        open_search:
          $ref: '#/components/schemas/OpenSearch'
        inspire:
          $ref: '#/components/schemas/Inspire'
        dublin_core_element_name:
          $ref: '#/components/schemas/DublinCoreElementName'
        raster_tile_url:
          $ref: '#/components/schemas/RasterTileURL'
        raster_tile_width:
          type: integer
          format: int32
        raster_tile_height:
          type: integer
          format: int32
        filter:
          $ref: '#/components/schemas/Filter'
        license_name:
          type: string
        license_urls:
          type: array
          items:
            type: string
    DublinCoreElementName:
      type: object
      properties:
        title:
          type: string
        creator:
          type: string
        subject:
          type: string
        description:
          type: string
        publisher:
          type: string
        contributor:
          type: string
        type:
          type: string
        format:
          type: string
        identifier:
          type: string
        source:
          type: string
        language:
          type: string
        bbox:
          $ref: '#/components/schemas/Bbox'
        date:
          type: string
        coverage:
          type: object
        coverage_centroid:
          type: string
    Expression:
      type: object
      properties:
        field:
          type: string
        op:
          type: string
          enum:
          - eq
          - gte
          - gt
          - lte
          - lt
          - like
          - ne
          - range
          - within
          - notwithin
          - intersects
          - notintersects
        value:
          type: string
    Feed:
      type: object
      properties:
        author:
          $ref: '#/components/schemas/Person'
        contributor:
          $ref: '#/components/schemas/Person'
        icon:
          type: string
        logo:
          type: string
        rights:
          type: string
        subtitle:
          type: string
        generator:
          $ref: '#/components/schemas/Generator'
    Filter:
      type: object
      properties:
        f:
          type: array
          items:
            type: array
            properties:
              empty:
                type: boolean
            items:
              $ref: '#/components/schemas/Expression'
        q:
          type: array
          items:
            type: array
            properties:
              empty:
                type: boolean
            items:
              type: string
        dateformat:
          type: string
        righthand:
          type: boolean
    Generator:
      type: object
      properties:
        name:
          type: string
        version:
          type: string
        uri:
          type: string
    Inspire:
      type: object
      properties:
        keywords:
          type: array
          items:
            $ref: '#/components/schemas/Keyword'
        topic_categories:
          type: array
          items:
            type: string
        lineage:
          type: string
        languages:
          type: array
          items:
            type: string
        spatial_resolution:
          $ref: '#/components/schemas/InspireSpatialResolution'
        inspire_uri:
          $ref: '#/components/schemas/InspireURI'
        inspire_limitation_access:
          $ref: '#/components/schemas/InspireLimitationAccess'
        inspire_use_conditions:
          type: string
    InspireLimitationAccess:
      type: object
      properties:
        access_constraints:
          type: string
        other_constraints:
          type: string
        classification:
          type: string
    InspireSpatialResolution:
      type: object
      properties:
        value:
          type: number
        unit_of_measure:
          type: string
    InspireURI:
      type: object
      properties:
        code:
          type: string
        namespace:
          type: string
    JSONObject:
      type: object
    Keyword:
      type: object
      properties:
        value:
          type: string
        vocabulary:
          type: string
        date_of_publication:
          type: string
    MultiValueFilterExpression:
      type: array
      properties:
        empty:
          type: boolean
      items:
        $ref: '#/components/schemas/Expression'
    MultiValueFilterString:
      type: array
      properties:
        empty:
          type: boolean
      items:
        type: string
    OpenSearch:
      type: object
      properties:
        short_name:
          type: string
        description:
          type: string
        contact:
          type: string
        tags:
          type: string
        long_name:
          type: string
        image_height:
          type: string
        image_width:
          type: string
        image_type:
          type: string
        image_url:
          type: string
        developer:
          type: string
        attribution:
          type: string
        syndication_right:
          type: string
        adult_content:
          type: string
        language:
          type: string
        input_encoding:
          type: string
        output_encoding:
          type: string
    Person:
      type: object
      properties:
        name:
          type: string
        email:
          type: string
        uri:
          type: string
    RasterTileURL:
      required:
      - id_path
      - url
      type: object
      properties:
        url:
          type: string
        id_path:
          type: string
        min_z:
          type: integer
          format: int32
        max_z:
          type: integer
          format: int32
        check_geometry:
          type: boolean
    FormDataContentDisposition:
      type: object
      properties:
        type:
          type: string
        parameters:
          type: object
          additionalProperties:
            type: string
        fileName:
          type: string
        creationDate:
          type: string
          format: date-time
        modificationDate:
          type: string
          format: date-time
        readDate:
          type: string
          format: date-time
        size:
          type: integer
          format: int64
        name:
          type: string
    CollectionReferenceUpdate:
      type: object
      properties:
        organisations:
          $ref: '#/components/schemas/CollectionReferenceUpdateOrg'
    CollectionReferenceUpdateOrg:
      type: object
      properties:
        public:
          type: boolean
        shared:
          type: array
          items:
            type: string
    AggregationMetric:
      type: object
      properties:
        type:
          type: string
        field:
          type: string
        value:
          type: object
    AggregationResponse:
      type: object
      properties:
        query_time:
          type: integer
          format: int64
        total_time:
          type: integer
          format: int64
        totalnb:
          type: integer
          format: int64
        name:
          type: string
        count:
          type: integer
          format: int64
        sumotherdoccounts:
          type: integer
          format: int64
        key:
          type: object
        key_as_string:
          type: object
        elements:
          type: array
          items:
            $ref: '#/components/schemas/AggregationResponse'
        metrics:
          type: array
          items:
            $ref: '#/components/schemas/AggregationMetric'
        hits:
          type: array
          items:
            type: object
        geometries:
          type: array
          items:
            $ref: '#/components/schemas/ReturnedGeometry'
        flattened_elements:
          type: object
          additionalProperties:
            type: object
    Crs:
      type: object
      properties:
        type:
          type: string
          enum:
          - name
          - link
        properties:
          type: object
          additionalProperties:
            type: object
    Feature:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          properties:
            type: object
            additionalProperties:
              type: object
          geometry:
            $ref: '#/components/schemas/GeoJsonObject'
          id:
            type: string
    FeatureCollection:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          features:
            type: array
            items:
              $ref: '#/components/schemas/Feature'
    GeoJsonObject:
      required:
      - type
      type: object
      properties:
        crs:
          $ref: '#/components/schemas/Crs'
        bbox:
          type: array
          items:
            type: number
            format: double
        type:
          type: string
      discriminator:
        propertyName: type
    GeometryCollection:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          geometries:
            type: array
            items:
              $ref: '#/components/schemas/GeoJsonObject'
    LineString:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              $ref: '#/components/schemas/LngLatAlt'
    LngLatAlt:
      type: object
      properties:
        longitude:
          type: number
          format: double
        latitude:
          type: number
          format: double
        altitude:
          type: number
          format: double
        additionalElements:
          type: array
          items:
            type: number
            format: double
    MultiLineString:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              type: array
              items:
                $ref: '#/components/schemas/LngLatAlt'
    MultiPoint:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              $ref: '#/components/schemas/LngLatAlt'
    MultiPolygon:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              type: array
              items:
                type: array
                items:
                  $ref: '#/components/schemas/LngLatAlt'
    Point:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            $ref: '#/components/schemas/LngLatAlt'
    Polygon:
      type: object
      allOf:
      - $ref: '#/components/schemas/GeoJsonObject'
      - type: object
        properties:
          coordinates:
            type: array
            items:
              type: array
              items:
                $ref: '#/components/schemas/LngLatAlt'
    ReturnedGeometry:
      type: object
      properties:
        reference:
          type: string
        geometry:
          $ref: '#/components/schemas/GeoJsonObject'
        sort:
          type: string
        is_raw:
          type: boolean
    Aggregation:
      type: object
      properties:
        type:
          type: string
          enum:
          - datehistogram
          - geohash
          - geotile
          - histogram
          - term
          - geohex
        field:
          type: string
        interval:
          $ref: '#/components/schemas/Interval'
        format:
          type: string
        metrics:
          type: array
          items:
            $ref: '#/components/schemas/Metric'
        order:
          type: string
          enum:
          - asc
          - desc
        "on":
          type: string
          enum:
          - field
          - count
          - result
        size:
          type: string
        include:
          type: string
        raw_geometries:
          type: array
          items:
            $ref: '#/components/schemas/RawGeometry'
        aggregated_geometries:
          type: array
          items:
            type: string
            enum:
            - BBOX
            - CENTROID
            - CELL
            - CELLCENTER
            - GEOHASH
            - GEOHASH_CENTER
        fetch_hits:
          $ref: '#/components/schemas/HitsFetcher'
    AggregationsRequest:
      type: object
      properties:
        filter:
          $ref: '#/components/schemas/Filter'
        form:
          $ref: '#/components/schemas/Form'
        aggregations:
          type: array
          items:
            $ref: '#/components/schemas/Aggregation'
    Form:
      type: object
      properties:
        pretty:
          type: boolean
        flat:
          type: boolean
    HitsFetcher:
      type: object
      properties:
        size:
          type: integer
          format: int32
        include:
          type: array
          items:
            type: string
    Interval:
      type: object
      properties:
        value:
          type: number
        unit:
          type: string
          enum:
          - year
          - quarter
          - month
          - week
          - day
          - hour
          - minute
          - second
    Metric:
      type: object
      properties:
        collect_field:
          type: string
        collect_fct:
          type: string
          enum:
          - AVG
          - CARDINALITY
          - MAX
          - MIN
          - SUM
          - GEOCENTROID
          - GEOBBOX
    RawGeometry:
      type: object
      properties:
        geometry:
          type: string
        sort:
          type: string
        signedSort:
          type: string
        include:
          type: array
          items:
            type: string
    ComputationResponse:
      type: object
      properties:
        query_time:
          type: integer
          format: int64
        total_time:
          type: integer
          format: int64
        totalnb:
          type: integer
          format: int64
        field:
          type: string
        metric:
          type: string
          enum:
          - AVG
          - MAX
          - MIN
          - SUM
          - CARDINALITY
          - SPANNING
          - GEOBBOX
          - GEOCENTROID
        value:
          type: number
          format: double
        geometry:
          $ref: '#/components/schemas/GeoJsonObject'
    ComputationRequest:
      type: object
      properties:
        filter:
          $ref: '#/components/schemas/Filter'
        form:
          $ref: '#/components/schemas/Form'
        field:
          type: string
        metric:
          type: string
          enum:
          - AVG
          - MAX
          - MIN
          - SUM
          - CARDINALITY
          - SPANNING
          - GEOBBOX
          - GEOCENTROID
    ArlasHit:
      type: object
      properties:
        md:
          $ref: '#/components/schemas/MD'
        data:
          type: object
    Geo:
      type: object
      properties:
        path:
          type: string
        geometry:
          $ref: '#/components/schemas/GeoJsonObject'
    Hits:
      type: object
      properties:
        collection:
          type: string
        hits:
          type: array
          items:
            $ref: '#/components/schemas/ArlasHit'
        nbhits:
          type: integer
          format: int64
        totalnb:
          type: integer
          format: int64
        links:
          type: object
          additionalProperties:
            $ref: '#/components/schemas/Link'
    Link:
      required:
      - href
      - method
      type: object
      properties:
        href:
          type: string
        method:
          type: string
        body:
          type: object
    MD:
      type: object
      properties:
        id:
          type: string
        timestamp:
          type: integer
          format: int64
        geometry:
          $ref: '#/components/schemas/GeoJsonObject'
        centroid:
          $ref: '#/components/schemas/GeoJsonObject'
        returned_geometries:
          type: array
          items:
            $ref: '#/components/schemas/Geo'
    Count:
      type: object
      properties:
        filter:
          $ref: '#/components/schemas/Filter'
        form:
          $ref: '#/components/schemas/Form'
    CollectionReferenceDescription:
      required:
      - collection_name
      - params
      type: object
      properties:
        properties:
          type: object
          additionalProperties:
            $ref: '#/components/schemas/CollectionReferenceDescriptionProperty'
        collection_name:
          type: string
        params:
          $ref: '#/components/schemas/CollectionReferenceParameters'
    CollectionReferenceDescriptionProperty:
      type: object
      properties:
        type:
          type: string
          enum:
          - TEXT
          - KEYWORD
          - LONG
          - INTEGER
          - SHORT
          - BYTE
          - DOUBLE
          - FLOAT
          - DATE
          - BOOLEAN
          - BINARY
          - INT_RANGE
          - FLOAT_RANGE
          - LONG_RANGE
          - DOUBLE_RANGE
          - DATE_RANGE
          - OBJECT
          - NESTED
          - GEO_POINT
          - GEO_SHAPE
          - IP
          - COMPLETION
          - TOKEN_COUNT
          - MAPPER_MURMUR3
          - UNKNOWN
          - VARCHAR
          - CHAR
          - CHARACTER
          - BIT
          - TINYINT
          - SMALLINT
          - INT
          - BIGINT
          - DECIMAL
          - NUMERIC
          - REAL
          - DOUBLEPRECISION
          - TIMESTAMP
          - TIME
          - INTERVAL
          - GEOMETRY
          - GEOGRAPHY
          - POINT
          - LINESTRING
          - POLYGON
          - MULTIPOINT
          - MULTILINESTRING
          - MULTIPOLYGON
          - GEOMETRYCOLLECTION
          - MURMUR3
        format:
          type: string
        hash_field:
          type: string
        taggable:
          type: boolean
        indexed:
          type: boolean
    Page:
      type: object
      properties:
        size:
          type: integer
          format: int32
        from:
          type: integer
          format: int32
        sort:
          type: string
        after:
          type: string
        before:
          type: string
    Projection:
      type: object
      properties:
        includes:
          type: string
        excludes:
          type: string
    Search:
      type: object
      properties:
        filter:
          $ref: '#/components/schemas/Filter'
        form:
          $ref: '#/components/schemas/Form'
        page:
          $ref: '#/components/schemas/Page'
        projection:
          $ref: '#/components/schemas/Projection'
        returned_geometries:
          type: string
