---
swagger: "2.0"
info:
  description: "Explore the content of ARLAS collections"
  version: "14.0.0-beta.4"
  title: "ARLAS Exploration API"
  contact:
    name: "Gisaia"
    url: "http://www.gisaia.com/"
    email: "contact@gisaia.com"
  license:
    name: "Apache 2.0"
    url: "https://www.apache.org/licenses/LICENSE-2.0.html"
basePath: "/arlas"
tags:
- name: "collections"
- name: "explore"
schemes:
- "http"
- "https"
paths:
  /collections:
    get:
      tags:
      - "collections"
      summary: "Get all collection references"
      description: "Get all collection references in ARLAS"
      operationId: "getAll"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            type: "array"
            items:
              $ref: "#/definitions/CollectionReference"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
  /collections/_export:
    get:
      tags:
      - "collections"
      summary: "Get all collection references as a json file"
      description: "Get all collection references in ARLAS as json file"
      operationId: "exportCollections"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters: []
      responses:
        200:
          description: "Successful operation"
          schema:
            type: "array"
            items:
              $ref: "#/definitions/CollectionReference"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
  /collections/_import:
    post:
      tags:
      - "collections"
      summary: "Add collection references from a json file"
      description: "Add collection references in ARLAS from a json file"
      operationId: "importCollections"
      consumes:
      - "multipart/form-data"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "file"
        in: "formData"
        required: false
        type: "file"
      responses:
        200:
          description: "Successful operation"
          schema:
            type: "string"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
  /collections/{collection}:
    get:
      tags:
      - "collections"
      summary: "Get a collection reference"
      description: "Get a collection reference in ARLAS"
      operationId: "get"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/CollectionReference"
        404:
          description: "Collection not found."
          schema:
            $ref: "#/definitions/Error"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
    put:
      tags:
      - "collections"
      summary: "Add a collection reference"
      description: "Add a collection reference in ARLAS"
      operationId: "put"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "collectionParams"
        description: "collectionParams"
        required: true
        schema:
          $ref: "#/definitions/CollectionReferenceParameters"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/CollectionReference"
        400:
          description: "JSON parameter malformed."
          schema:
            $ref: "#/definitions/Error"
        404:
          description: "Not Found Error."
          schema:
            $ref: "#/definitions/Error"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
    delete:
      tags:
      - "collections"
      summary: "Delete a collection reference"
      description: "Delete a collection reference in ARLAS"
      operationId: "delete"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Success"
        404:
          description: "Collection not found."
          schema:
            $ref: "#/definitions/Error"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_aggregate:
    get:
      tags:
      - "explore"
      summary: "Aggregate"
      description: "Aggregate the elements in the collection(s), given the filters\
        \ and the aggregation parameters"
      operationId: "aggregate"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "agg"
        in: "query"
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}\
          \ \n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n \n   -\
          \ **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types. \n \n   - It's possible\
          \ to apply multiple metric aggregations by defining multiple (**collect_field**,**collect_fct**)\
          \ couples.\n \n   - (**collect_field**,**collect_fct**) couples should be\
          \ unique in that case.\n \n   - (**order**,**on**) couple is optional for\
          \ all aggregation types.\n \n   - **size** is optional for term and geohash,\
          \ and must not be specified for the other types.\n \n   - **include** is\
          \ optional for term, and must not be specified for the other types.\n \n\
          - {type} possible values are : \n \n       datehistogram, histogram, geohash\
          \ and term. \n \n- {interval} possible values depends on {type}. \n \n \
          \      If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = term, then interval-{interval} is not needed. \n\
          \ \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum\n \n- {order}\
          \ is set to sort the aggregation buckets on the field name, on the count\
          \ of the buckets or on the the result of a metric sub-aggregation. Its values\
          \ are 'asc' or 'desc'. \n \n- {on} is set to specify whether the {order}\
          \ is on the field name, on the count of the aggregation or on the result\
          \ of a metric sub-aggregation. Its values are 'field', 'count' or 'result'.\
          \ \n \n- If {on} is equal to `result` and two or more (**collect_field**,**collect_fct**)\
          \ couples are specified, then the order is applied on the first `collect_fct`\
          \ that is different from geobbox and geocentroid\n \n- {size} Defines how\
          \ many buckets should be returned. \n \n- {include} Specifies the values\
          \ for which buckets will be created. This values are comma separated. If\
          \ one value is specified then regular expressions can be used (only in this\
          \ case) and buckets matching them will be created. If more than one value\
          \ are specified then only buckets matching the exact values will be created.\n\
          \ \n- **aggregated_geometries**\n \n    > **What it does**: Allows to specify\
          \ a list of aggregated forms of geometries that represent the bucket.\n\
          \ \n    > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.\n\
          \ \n    > __**Available aggregated geometries**__: `centroid, bbox, geohash,\
          \ geohash_center`.\n \n       - **centroid**: returns the centroid of data\
          \ inside the bucket.\n \n       - **bbox**: returns the data extent (bbox)\
          \ in each bucket.\n \n       - **geohash**: returns the 'geohash' extent\
          \ of each bucket. This form is supported for **geohash** aggregation type\
          \ only.\n \n       - **geohash_center**: returns the geohash center of each\
          \ bucket. This form is supported for **geohash** aggregation type only.\n\
          \ \n    > __**Response**__: the aggregated geometries are returned in `geometries`\
          \ list in the json response. Each object inside this list has : the reference\
          \ to the aggregated form, the geojson geometry and an attribute `is_raw`\
          \ set to false\n \n    > __**Example**__: `aggregated_geometries-bbox,geohash`\n\
          \ \n- **raw_geometries**\n \n    > **What it does**: Allows to specify a\
          \ list of raw geometries provided by hits that represent the bucket and\
          \ that are elected by a sort\n \n    > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.\n\
          \ \n    > __**Available raw geometries**__: any field of the collection\
          \ whose type is **geo-point** or **geo-shape**.\n \n       - sort fields\
          \ are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path`\
          \ is applied\n \n       - a sort field can be preceded by '-' for descending\
          \ sort. Otherwise the sort is ascending\n \n    > __**Response**__: the\
          \ aggregated geometries are returned in `geometries` list in the json response.\
          \ Each object inside this list has : the reference to the geometry path,\
          \ the used sort, the geojson geometry and an attribute `is_raw` set to true\n\
          \ \n    > __**Example**__: `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)`\
          \ || raw_geometries-geo_field1(field1);geo_field2(field2,field3)\n \n- **fetch_hits**\
          \ \n \n    > **What it does**: Specifies the number of hits to retrieve\
          \ inside each aggregation bucket and which fields to include in the hits.\n\
          \ \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2},\
          \ -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional,\
          \ if not specified, 1 is considered as default.\n \n    > **Note 2**: `{field}`\
          \ can be preceded by **+** or **-** for **ascending** or **descending**\
          \ sort of the hits. Order matters.\n \n    > __**Example**__: `fetch_hits-3(-timestamp,\
          \ geometry)`. Fetches the 3 last positions for each bucket.\n \n**agg**\
          \ parameter is multiple. Every agg parameter specified is a subaggregation\
          \ of the previous one : order matters. \n \nFor more details, check https://gitlab.com/GISAIA.ARLAS/ARLAS-server/blob/master/doc/api/API-definition.md."
        required: true
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/AggregationResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "Aggregate"
      description: "Aggregate the elements in the collection(s), given the filters\
        \ and the aggregation parameters"
      operationId: "aggregatePost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/AggregationsRequest"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/AggregationResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_geoaggregate:
    get:
      tags:
      - "explore"
      summary: "GeoAggregate"
      description: "Aggregate the elements in the collection(s) as features, given\
        \ the filters and the aggregation parameters."
      operationId: "geoaggregate"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "agg"
        in: "query"
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:fetcbGeometry-{fetch_geometry\
          \ values}\n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types.\n \n   - (**order**,**on**)\
          \ couple is optional for all aggregation types.\n \n   - **size** is optional\
          \ for term and geohash, and must not be specified for the other types.\n\
          \ \n   - **include** is optional for term, and must not be specified for\
          \ the other types.\n \n- {type} possible values are : \n \n       geohash,\
          \ datehistogram, histogram and term. geohash must be the main aggregation.\n\
          \ \n- {interval} possible values depends on {type}. \n \n       If {type}\
          \ = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = term, then interval-{interval} is not needed. \n\
          \ \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum,geobbox,geocentroid\n\
          \ \n- (collect_field,collect_fct) should both be specified, except when\
          \ collect_fct = `geobbox` or `geocentroid`, it could be specified alone.\
          \ The metrics `geobbox` and `geocentroid` are returned as features collections.\n\
          \ \n- {order} is set to sort the aggregation buckets on the field name,\
          \ on the count of the buckets or on the the result of a metric sub-aggregation.\
          \ Its values are 'asc' or 'desc'. \n \n- {on} is set to specify whether\
          \ the {order} is on the field name, on the count of the aggregation or on\
          \ the result of a metric sub-aggregation. Its values are 'field', 'count'\
          \ or 'result'. \n \n- When {on} = `result`, then (collect_field,collect_fct)\
          \ should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`,\
          \ then {on}=`result` is prohibited\n \n- {size} Defines how many buckets\
          \ should be returned. \n \n- {include} Specifies the values for which buckets\
          \ will be created. This values are comma separated. If one value is specified\
          \ then regular expressions can be used (only in this case) and buckets matching\
          \ them will be created. If more than one value are specified then only buckets\
          \ matching the exact values will be created.\n \n- **aggregated_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of aggregated forms\
          \ of geometries that represent the bucket.\n \n    > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.\n\
          \ \n    > __**Available aggregated geometries**__: `centroid, bbox, geohash,\
          \ geohash_center`.\n \n       - **centroid**: returns the centroid of data\
          \ inside the bucket.\n \n       - **bbox**: returns the data extent (bbox)\
          \ in each bucket.\n \n       - **geohash**: returns the 'geohash' extent\
          \ of each bucket. This form is supported for **geohash** aggregation type\
          \ only.\n \n       - **geohash_center**: returns the geohash center of each\
          \ bucket. This form is supported for **geohash** aggregation type only.\n\
          \ \n    > __**Response**__: Each bucket of the aggregation will be represented\
          \ with as many features (in a feature collection) as there are specified\
          \ aggregated geometries. The properties of each feature has :\n \n     \
          \  - **geometry_ref** attribute that informs which aggregated form is returned\
          \ \n \n       - **geometry_type** attribute set to *aggregated*\n \n   \
          \ > __**Example**__: `aggregated_geometries-bbox,geohash`\n \n- **raw_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of raw geometries provided\
          \ by hits that represent the bucket and thata are elected by a sort\n \n\
          \    > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.\n\
          \ \n    > __**Available raw geometries**__: any field of the collection\
          \ whose type is **geo-point** or **geo-shape**.\n \n       - sort fields\
          \ are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path`\
          \ is applied\n \n       - a sort field can be preceded by '-' for descending\
          \ sort. Otherwise the sort is ascending\n \n    > __**Response**__: each\
          \ bucket of the aggregation will be represented with as many features (in\
          \ a feature collection) as there are specified raw geometries. The properties\
          \ of each feature has :\n \n       - **geometry_ref** attribute that informs\
          \ which geometry path is returned \n \n       - **geometry_type** attribute\
          \ set to *raw*\n \n       - **geometry_sort** attribute that informs how\
          \ the geometry path is fetched (with what sort)\n \n    > __**Example**__:\
          \ `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)`\
          \ || raw_geometries-geo_field1(field1);geo_field2(field2,field3)\n \n- **fetch_hits**\
          \ \n \n    > **What it does**: Specifies the number of hits to retrieve\
          \ inside each aggregation bucket and which fields to include in the hits.\n\
          \ \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2},\
          \ -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional,\
          \ if not specified, 1 is considered as default.\n \n    > **Note 2**: `{field}`\
          \ can be preceded by **+** or **-** for **ascending** or **descending**\
          \ sort of the hits. Order matters.\n \n    > __**Example**__: `fetch_hits-3(-timestamp,\
          \ geometry)`. Fetches the 3 last positions for each bucket.\n \n**agg**\
          \ parameter is multiple. The first (main) aggregation must be geohash. Every\
          \ agg parameter specified is a subaggregation of the previous one : order\
          \ matters. \n \nFor more details, check https://github.com/gisaia/ARLAS-server/blob/master/docs/arlas-api-exploration.md "
        required: true
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
        501:
          description: "Not implemented functionality."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "GeoAggregate"
      description: "Aggregate the elements in the collection(s) as features, given\
        \ the filters and the aggregation parameters."
      operationId: "geoaggregatePost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/AggregationsRequest"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
        501:
          description: "Not implemented functionality."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_geoaggregate/{geohash}:
    get:
      tags:
      - "explore"
      summary: "GeoAggregate on a geohash"
      description: "Aggregate the elements in the collection(s) and localized in the\
        \ given geohash as features, given the filters and the aggregation parameters."
      operationId: "geohashgeoaggregate"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "geohash"
        in: "path"
        description: "geohash"
        required: true
        type: "string"
      - name: "agg"
        in: "query"
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:fetcbGeometry-{fetch_geometry\
          \ values}\n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types.\n \n   - (**order**,**on**)\
          \ couple is optional for all aggregation types.\n \n   - **size** is optional\
          \ for term and geohash, and must not be specified for the other types.\n\
          \ \n   - **include** is optional for term, and must not be specified for\
          \ the other types.\n \n- {type} possible values are : \n \n       geohash,\
          \ datehistogram, histogram and term. geohash must be the main aggregation.\n\
          \ \n- {interval} possible values depends on {type}. \n \n       If {type}\
          \ = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = term, then interval-{interval} is not needed. \n\
          \ \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum,geobbox,geocentroid\n\
          \ \n- (collect_field,collect_fct) should both be specified, except when\
          \ collect_fct = `geobbox` or `geocentroid`, it could be specified alone.\
          \ The metrics `geobbox` and `geocentroid` are returned as features collections.\n\
          \ \n- {order} is set to sort the aggregation buckets on the field name,\
          \ on the count of the buckets or on the the result of a metric sub-aggregation.\
          \ Its values are 'asc' or 'desc'. \n \n- {on} is set to specify whether\
          \ the {order} is on the field name, on the count of the aggregation or on\
          \ the result of a metric sub-aggregation. Its values are 'field', 'count'\
          \ or 'result'. \n \n- When {on} = `result`, then (collect_field,collect_fct)\
          \ should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`,\
          \ then {on}=`result` is prohibited\n \n- {size} Defines how many buckets\
          \ should be returned. \n \n- {include} Specifies the values for which buckets\
          \ will be created. This values are comma separated. If one value is specified\
          \ then regular expressions can be used (only in this case) and buckets matching\
          \ them will be created. If more than one value are specified then only buckets\
          \ matching the exact values will be created.\n \n- **aggregated_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of aggregated forms\
          \ of geometries that represent the bucket.\n \n    > __**Syntax**__: `aggregated_geometries-{COMMA_SEPARATED_AGGREGATED_GEOMETRIES}`.\n\
          \ \n    > __**Available aggregated geometries**__: `centroid, bbox, geohash,\
          \ geohash_center`.\n \n       - **centroid**: returns the centroid of data\
          \ inside the bucket.\n \n       - **bbox**: returns the data extent (bbox)\
          \ in each bucket.\n \n       - **geohash**: returns the 'geohash' extent\
          \ of each bucket. This form is supported for **geohash** aggregation type\
          \ only.\n \n       - **geohash_center**: returns the geohash center of each\
          \ bucket. This form is supported for **geohash** aggregation type only.\n\
          \ \n    > __**Response**__: Each bucket of the aggregation will be represented\
          \ with as many features (in a feature collection) as there are specified\
          \ aggregated geometries. The properties of each feature has :\n \n     \
          \  - **geometry_ref** attribute that informs which aggregated form is returned\
          \ \n \n       - **geometry_type** attribute set to *aggregated*\n \n   \
          \ > __**Example**__: `aggregated_geometries-bbox,geohash`\n \n- **raw_geometries**\n\
          \ \n    > **What it does**: Allows to specify a list of raw geometries provided\
          \ by hits that represent the bucket and thata are elected by a sort\n \n\
          \    > __**Syntax**__: `raw_geometries-{GEOMETRY_FIELD}({COMMA_SEPERATED_SORT_FIELDS});{GEOMETRY_FIELD2}({COMMA_SEPERATED_SORT_FIELDS2})`.\n\
          \ \n    > __**Available raw geometries**__: any field of the collection\
          \ whose type is **geo-point** or **geo-shape**.\n \n       - sort fields\
          \ are optional. If no sort is specified, an ascending sort on `collection.params.timestamp_path`\
          \ is applied\n \n       - a sort field can be preceded by '-' for descending\
          \ sort. Otherwise the sort is ascending\n \n    > __**Response**__: each\
          \ bucket of the aggregation will be represented with as many features (in\
          \ a feature collection) as there are specified raw geometries. The properties\
          \ of each feature has :\n \n       - **geometry_ref** attribute that informs\
          \ which geometry path is returned \n \n       - **geometry_type** attribute\
          \ set to *raw*\n \n       - **geometry_sort** attribute that informs how\
          \ the geometry path is fetched (with what sort)\n \n    > __**Example**__:\
          \ `raw_geometries-geo_field1,geo_field2  ||  raw_geometries-geo_field(-field1,field2)`\
          \ || raw_geometries-geo_field1(field1);geo_field2(field2,field3)\n \n- **fetch_hits**\
          \ \n \n    > **What it does**: Specifies the number of hits to retrieve\
          \ inside each aggregation bucket and which fields to include in the hits.\n\
          \ \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1}, {field2},\
          \ -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional,\
          \ if not specified, 1 is considered as default.\n \n    > **Note 2**: `{field}`\
          \ can be preceded by **+** or **-** for **ascending** or **descending**\
          \ sort of the hits. Order matters.\n \n    > __**Example**__: `fetch_hits-3(-timestamp,\
          \ geometry)`. Fetches the 3 last positions for each bucket.\n \n**agg**\
          \ parameter is multiple. The first (main) aggregation must be geohash. Every\
          \ agg parameter specified is a subaggregation of the previous one : order\
          \ matters. \n \nFor more details, check https://github.com/gisaia/ARLAS-server/blob/master/docs/arlas-api-exploration.md "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
        501:
          description: "Not implemented functionality."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_compute:
    get:
      tags:
      - "explore"
      summary: "Compute"
      description: "Computes the given metric on a field in the collection, given\
        \ the filters"
      operationId: "compute"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "field"
        in: "query"
        description: "The field on which the metric is calculated."
        required: true
        type: "string"
      - name: "metric"
        in: "query"
        description: "The metric to compute : `max, min, avg, sum, cardinality, spanning,\
          \ geobbox, geocentroid`."
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/ComputationResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "Compute"
      description: "Computes the given metric on a field in the collection, given\
        \ the filters"
      operationId: "computePost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/ComputationRequest"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/ComputationResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_count:
    get:
      tags:
      - "explore"
      summary: "Count"
      description: "Count the number of elements found in the collection(s), given\
        \ the filters"
      operationId: "count"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collections"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hits"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "Count"
      description: "Count the number of elements found in the collection(s), given\
        \ the filters"
      operationId: "countPost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collections"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/Count"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hits"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_describe:
    get:
      tags:
      - "explore"
      summary: "Describe"
      description: "Describe the structure and the content of the given collection. "
      operationId: "describe"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/CollectionReferenceDescription"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/_list:
    get:
      tags:
      - "explore"
      summary: "List"
      description: "List the collections configured in ARLAS. "
      operationId: "list"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            type: "array"
            items:
              $ref: "#/definitions/CollectionReferenceDescription"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/ogc/opensearch/{collection}:
    get:
      tags:
      - "explore"
      summary: "OpenSearch Description Document"
      description: "Access to the OpenSearch Description document for the given collection"
      operationId: "opensearch"
      produces:
      - "application/xml"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/{identifier}:
    get:
      tags:
      - "explore"
      summary: "Get an Arlas document"
      description: "Returns a raw indexed document."
      operationId: "getArlasHit"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "identifier"
        in: "path"
        description: "identifier"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hit"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
        404:
          description: "Not Found Error."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_geosearch:
    get:
      tags:
      - "explore"
      summary: "GeoSearch"
      description: "Search and return the elements found in the collection(s) as features,\
        \ given the filters"
      operationId: "geosearch"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "include"
        in: "query"
        description: "List the name patterns of the field to be included in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
          default: "*"
        collectionFormat: "multi"
      - name: "exclude"
        in: "query"
        description: "List the name patterns of the field to be excluded in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "returned_geometries"
        in: "query"
        description: "Comma separated geometry field_paths to be included in the result.\
          \ If not specified, only geometry_path is returned. If geometry_path is\
          \ null, then centroid_path is returned"
        required: false
        type: "string"
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 0
      - name: "sort"
        in: "query"
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89°,179°)\n\
          \ \n"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "after"
        in: "query"
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        required: false
        type: "string"
      - name: "before"
        in: "query"
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        required: false
        type: "string"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "GeoSearch"
      description: "Search and return the elements found in the collection(s) as features,\
        \ given the filters"
      operationId: "geosearchPost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/Search"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_geosearch/{z}/{x}/{y}:
    get:
      tags:
      - "explore"
      summary: "Tiled GeoSearch"
      description: "Search and return the elements found in the collection(s) and\
        \ localized in the given tile(x,y,z) as features, given the filters"
      operationId: "tiledgeosearch"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "x"
        in: "path"
        description: "x"
        required: true
        type: "integer"
        format: "int32"
      - name: "y"
        in: "path"
        description: "y"
        required: true
        type: "integer"
        format: "int32"
      - name: "z"
        in: "path"
        description: "z"
        required: true
        type: "integer"
        format: "int32"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "include"
        in: "query"
        description: "List the name patterns of the field to be included in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
          default: "*"
        collectionFormat: "multi"
      - name: "exclude"
        in: "query"
        description: "List the name patterns of the field to be excluded in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "returned_geometries"
        in: "query"
        description: "Comma separated geometry field_paths to be included in the result.\
          \ If not specified, only geometry_path is returned. If geometry_path is\
          \ null, then centroid_path is returned"
        required: false
        type: "string"
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 0
      - name: "sort"
        in: "query"
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89°,179°)\n\
          \ \n"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "after"
        in: "query"
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        required: false
        type: "string"
      - name: "before"
        in: "query"
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        required: false
        type: "string"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_search:
    get:
      tags:
      - "explore"
      summary: "Search"
      description: "Search and return the elements found in the collection, given\
        \ the filters"
      operationId: "search"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      - "application/atom+xml"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "include"
        in: "query"
        description: "List the name patterns of the field to be included in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
          default: "*"
        collectionFormat: "multi"
      - name: "exclude"
        in: "query"
        description: "List the name patterns of the field to be excluded in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "returned_geometries"
        in: "query"
        description: "Comma separated geometry field_paths to be included in the result.\
          \ If not specified, only geometry_path is returned. If geometry_path is\
          \ null, then centroid_path is returned"
        required: false
        type: "string"
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 0
      - name: "sort"
        in: "query"
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89°,179°)\n\
          \ \n"
        required: false
        type: "string"
      - name: "after"
        in: "query"
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        required: false
        type: "string"
      - name: "before"
        in: "query"
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        required: false
        type: "string"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hits"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "Search"
      description: "Search and return the elements found in the collection, given\
        \ the filters"
      operationId: "searchPost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/Search"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hits"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collections}/_suggest:
    get:
      tags:
      - "explore"
      summary: "Suggest"
      description: "Suggest the the n (n=size) most relevant terms given the filters"
      operationId: "suggest"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collections"
        in: "path"
        description: "collections, comma separated"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided. The order does not matter. \n \n- A triplet is composed of a\
          \ field name, a comparison operator and a value. \n \n  The possible values\
          \ of the comparison operator are : \n \n       Operator   |            \
          \       Description                      | value type\n \n       :     \
          \     |  {fieldName} equals {value}                        | numeric or\
          \ strings \n \n       :gte:      |  {fieldName} is greater than or equal\
          \ to  {value}  | numeric \n \n       :gt:       |  {fieldName} is greater\
          \ than {value}               | numeric \n \n       :lte:      |  {fieldName}\
          \ is less than or equal to {value}      | numeric \n \n       :lt:     \
          \  |  {fieldName}  is less than {value}                 | numeric \n \n\n\
          \ \n- The AND operator is applied between filters having different fieldNames.\
          \ \n \n- The OR operator is applied on filters having the same fieldName.\
          \ \n \n- If the fieldName starts with - then a must not filter is used\n\
          \ \n- If the fieldName starts with - then a must not filter is used\n \n\
          For more details, check https://gitlab.com/GISAIA.ARLAS/ARLAS-server/blob/master/doc/api/API-definition.md "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
        format: "int32"
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 1
        format: "int32"
      - name: "field"
        in: "query"
        description: "Name of the field to be used for retrieving the most relevant\
          \ terms"
        required: false
        type: "string"
        default: "_all"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
  /explore/{collection}/_tile/{z}/{x}/{y}.png:
    get:
      tags:
      - "explore"
      summary: "Tiled GeoSearch"
      description: "Search and return the elements found in the collection(s) and\
        \ localized in the given tile(x,y,z) as features, given the filters"
      operationId: "tiledgeosearch_1"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "image/png"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "x"
        in: "path"
        description: "x"
        required: true
        type: "integer"
        format: "int32"
      - name: "y"
        in: "path"
        description: "y"
        required: true
        type: "integer"
        format: "int32"
      - name: "z"
        in: "path"
        description: "z"
        required: true
        type: "integer"
        format: "int32"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression\n \n       :within: | {GeofieldName}`\
          \ is within the `{given WKT string or the given BBOX }` | a WKT string or\
          \ the BBOX string : `\"west, south, east, north\"` \n \n       :notwithin:|\
          \ {GeofieldName} is not within the `{given WKT string or the given BBOX\
          \ }` | a WKT string or the BBOX string : `\"west, south, east, north\"`\
          \ \n \n       :intersects:| {GeofieldName} intersects the `{given WKT string\
          \ or the given BBOX }` | a WKT string or the BBOX string : `\"west, south,\
          \ east, north\"` \n \n       :notintersects:| {GeofieldName} does not intersect\
          \ the `{given WKT string or the given }` | a WKT string or the BBOX string\
          \ : `\"west, south, east, north\"` "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 0
      - name: "sort"
        in: "query"
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89°,179°)\n\
          \ \n"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "after"
        in: "query"
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        required: false
        type: "string"
      - name: "before"
        in: "query"
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        required: false
        type: "string"
      - name: "sampling"
        in: "query"
        description: "Size of the sampling for testing transparency: 1: test every\
          \ pixel, 10: test 1 pixel every 10 pixels, etc."
        required: false
        type: "integer"
        default: 10
        format: "int32"
      - name: "coverage"
        in: "query"
        description: "Percentage (]0-100]) of acceptable transparent pixels. Higher\
          \ the percentage, more tiles could be used for filling the tile"
        required: false
        type: "integer"
        default: 70
        format: "int32"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
definitions:
  Bbox:
    type: "object"
    required:
    - "east"
    - "north"
    - "south"
    - "west"
    properties:
      north:
        type: "number"
        format: "double"
      south:
        type: "number"
        format: "double"
      east:
        type: "number"
        format: "double"
      west:
        type: "number"
        format: "double"
  CollectionReference:
    type: "object"
    required:
    - "collection_name"
    - "params"
    properties:
      collection_name:
        type: "string"
      params:
        $ref: "#/definitions/CollectionReferenceParameters"
  CollectionReferenceParameters:
    type: "object"
    required:
    - "centroid_path"
    - "geometry_path"
    - "id_path"
    - "index_name"
    - "timestamp_path"
    properties:
      index_name:
        type: "string"
      id_path:
        type: "string"
      geometry_path:
        type: "string"
      centroid_path:
        type: "string"
      timestamp_path:
        type: "string"
      exclude_fields:
        type: "string"
      update_max_hits:
        type: "integer"
        format: "int32"
      taggable_fields:
        type: "string"
      exclude_wfs_fields:
        type: "string"
      custom_params:
        type: "object"
        additionalProperties:
          type: "string"
      atom_feed:
        $ref: "#/definitions/Feed"
      open_search:
        $ref: "#/definitions/OpenSearch"
      inspire:
        $ref: "#/definitions/Inspire"
      dublin_core_element_name:
        $ref: "#/definitions/DublinCoreElementName"
      raster_tile_url:
        $ref: "#/definitions/RasterTileURL"
      raster_tile_width:
        type: "integer"
        format: "int32"
      raster_tile_height:
        type: "integer"
        format: "int32"
      filter:
        $ref: "#/definitions/Filter"
  DublinCoreElementName:
    type: "object"
    properties:
      title:
        type: "string"
      creator:
        type: "string"
      subject:
        type: "string"
      description:
        type: "string"
      publisher:
        type: "string"
      contributor:
        type: "string"
      type:
        type: "string"
      format:
        type: "string"
      identifier:
        type: "string"
      source:
        type: "string"
      language:
        type: "string"
      bbox:
        $ref: "#/definitions/Bbox"
      date:
        type: "string"
      coverage:
        type: "object"
        additionalProperties:
          type: "object"
      coverage_centroid:
        type: "string"
  Expression:
    type: "object"
    properties:
      field:
        type: "string"
      op:
        type: "string"
        enum:
        - "eq"
        - "gte"
        - "gt"
        - "lte"
        - "lt"
        - "like"
        - "ne"
        - "range"
        - "within"
        - "notwithin"
        - "intersects"
        - "notintersects"
      value:
        type: "string"
  Feed:
    type: "object"
    properties:
      author:
        $ref: "#/definitions/Person"
      contributor:
        $ref: "#/definitions/Person"
      icon:
        type: "string"
      logo:
        type: "string"
      rights:
        type: "string"
      subtitle:
        type: "string"
      generator:
        $ref: "#/definitions/Generator"
  Filter:
    type: "object"
    properties:
      f:
        type: "array"
        items:
          type: "array"
          items:
            $ref: "#/definitions/Expression"
      q:
        type: "array"
        items:
          type: "array"
          items:
            type: "string"
      dateformat:
        type: "string"
  Generator:
    type: "object"
    properties:
      name:
        type: "string"
      version:
        type: "string"
      uri:
        type: "string"
  Inspire:
    type: "object"
    properties:
      keywords:
        type: "array"
        items:
          $ref: "#/definitions/Keyword"
      topic_categories:
        type: "array"
        items:
          type: "string"
      lineage:
        type: "string"
      languages:
        type: "array"
        items:
          type: "string"
      spatial_resolution:
        $ref: "#/definitions/InspireSpatialResolution"
      inspire_uri:
        $ref: "#/definitions/InspireURI"
      inspire_limitation_access:
        $ref: "#/definitions/InspireLimitationAccess"
      inspire_use_conditions:
        type: "string"
  InspireLimitationAccess:
    type: "object"
    properties:
      access_constraints:
        type: "string"
      other_constraints:
        type: "string"
      classification:
        type: "string"
  InspireSpatialResolution:
    type: "object"
    properties:
      value:
        $ref: "#/definitions/Number"
      unit_of_measure:
        type: "string"
  InspireURI:
    type: "object"
    properties:
      code:
        type: "string"
      namespace:
        type: "string"
  Keyword:
    type: "object"
    properties:
      value:
        type: "string"
      vocabulary:
        type: "string"
      date_of_publication:
        type: "string"
  Number:
    type: "object"
  OpenSearch:
    type: "object"
    properties:
      short_name:
        type: "string"
      description:
        type: "string"
      contact:
        type: "string"
      tags:
        type: "string"
      long_name:
        type: "string"
      image_height:
        type: "string"
      image_width:
        type: "string"
      image_type:
        type: "string"
      image_url:
        type: "string"
      developer:
        type: "string"
      attribution:
        type: "string"
      syndication_right:
        type: "string"
      adult_content:
        type: "string"
      language:
        type: "string"
      input_encoding:
        type: "string"
      output_encoding:
        type: "string"
  Person:
    type: "object"
    properties:
      name:
        type: "string"
      email:
        type: "string"
      uri:
        type: "string"
  RasterTileURL:
    type: "object"
    required:
    - "id_path"
    - "url"
    properties:
      url:
        type: "string"
      id_path:
        type: "string"
      min_z:
        type: "integer"
        format: "int32"
      max_z:
        type: "integer"
        format: "int32"
      check_geometry:
        type: "boolean"
  Error:
    type: "object"
    properties:
      status:
        type: "integer"
        format: "int32"
      message:
        type: "string"
      error:
        type: "string"
  Success:
    type: "object"
    properties:
      status:
        type: "integer"
        format: "int32"
      message:
        type: "string"
  AggregationMetric:
    type: "object"
    properties:
      type:
        type: "string"
      field:
        type: "string"
      value:
        type: "object"
  AggregationResponse:
    type: "object"
    properties:
      query_time:
        type: "integer"
        format: "int64"
      total_time:
        type: "integer"
        format: "int64"
      totalnb:
        type: "integer"
        format: "int64"
      name:
        type: "string"
      count:
        type: "integer"
        format: "int64"
      sumotherdoccounts:
        type: "integer"
        format: "int64"
      key:
        type: "object"
      key_as_string:
        type: "object"
      elements:
        type: "array"
        items:
          $ref: "#/definitions/AggregationResponse"
      metrics:
        type: "array"
        items:
          $ref: "#/definitions/AggregationMetric"
      hits:
        type: "array"
        items:
          type: "object"
      geometries:
        type: "array"
        items:
          $ref: "#/definitions/ReturnedGeometry"
      flattened_elements:
        type: "object"
        additionalProperties:
          type: "object"
  Crs:
    type: "object"
    properties:
      type:
        type: "string"
        enum:
        - "name"
        - "link"
      properties:
        type: "object"
        additionalProperties:
          type: "object"
  Feature:
    type: "object"
    properties:
      crs:
        $ref: "#/definitions/Crs"
      bbox:
        type: "array"
        items:
          type: "number"
          format: "double"
      properties:
        type: "object"
        additionalProperties:
          type: "object"
      geometry:
        $ref: "#/definitions/GeoJsonObject"
      id:
        type: "string"
  FeatureCollection:
    type: "object"
    properties:
      crs:
        $ref: "#/definitions/Crs"
      bbox:
        type: "array"
        items:
          type: "number"
          format: "double"
      features:
        type: "array"
        items:
          $ref: "#/definitions/Feature"
  GeoJsonObject:
    type: "object"
    discriminator: "type"
    properties:
      crs:
        $ref: "#/definitions/Crs"
      bbox:
        type: "array"
        items:
          type: "number"
          format: "double"
  GeometryCollection:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        geometries:
          type: "array"
          items:
            $ref: "#/definitions/GeoJsonObject"
  LineString:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            $ref: "#/definitions/LngLatAlt"
  LngLatAlt:
    type: "object"
  MultiLineString:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            type: "array"
            items:
              $ref: "#/definitions/LngLatAlt"
  MultiPoint:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            $ref: "#/definitions/LngLatAlt"
  MultiPolygon:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            type: "array"
            items:
              type: "array"
              items:
                $ref: "#/definitions/LngLatAlt"
  Point:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          $ref: "#/definitions/LngLatAlt"
  Polygon:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            type: "array"
            items:
              $ref: "#/definitions/LngLatAlt"
  ReturnedGeometry:
    type: "object"
    properties:
      reference:
        type: "string"
      geometry:
        $ref: "#/definitions/GeoJsonObject"
      sort:
        type: "string"
      is_raw:
        type: "boolean"
  Aggregation:
    type: "object"
    properties:
      type:
        type: "string"
        enum:
        - "datehistogram"
        - "geohash"
        - "histogram"
        - "term"
      field:
        type: "string"
      interval:
        $ref: "#/definitions/Interval"
      format:
        type: "string"
      metrics:
        type: "array"
        items:
          $ref: "#/definitions/Metric"
      order:
        type: "string"
        enum:
        - "asc"
        - "desc"
      on:
        type: "string"
        enum:
        - "field"
        - "count"
        - "result"
      size:
        type: "string"
      include:
        type: "string"
      raw_geometries:
        type: "array"
        items:
          $ref: "#/definitions/RawGeometry"
      aggregated_geometries:
        type: "array"
        items:
          type: "string"
          enum:
          - "BBOX"
          - "CENTROID"
          - "GEOHASH"
          - "GEOHASHCENTER"
      fetch_hits:
        $ref: "#/definitions/HitsFetcher"
  AggregationsRequest:
    type: "object"
    properties:
      filter:
        $ref: "#/definitions/Filter"
      form:
        $ref: "#/definitions/Form"
      aggregations:
        type: "array"
        items:
          $ref: "#/definitions/Aggregation"
  Form:
    type: "object"
    properties:
      pretty:
        type: "boolean"
      flat:
        type: "boolean"
  HitsFetcher:
    type: "object"
    properties:
      size:
        type: "integer"
        format: "int32"
      include:
        type: "array"
        items:
          type: "string"
  Interval:
    type: "object"
    properties:
      value:
        $ref: "#/definitions/Number"
      unit:
        type: "string"
        enum:
        - "year"
        - "quarter"
        - "month"
        - "week"
        - "day"
        - "hour"
        - "minute"
        - "second"
  Metric:
    type: "object"
    properties:
      collect_field:
        type: "string"
      collect_fct:
        type: "string"
        enum:
        - "AVG"
        - "CARDINALITY"
        - "MAX"
        - "MIN"
        - "SUM"
        - "GEOCENTROID"
        - "GEOBBOX"
  RawGeometry:
    type: "object"
    properties:
      geometry:
        type: "string"
      sort:
        type: "string"
  ComputationResponse:
    type: "object"
    properties:
      query_time:
        type: "integer"
        format: "int64"
      total_time:
        type: "integer"
        format: "int64"
      totalnb:
        type: "integer"
        format: "int64"
      field:
        type: "string"
      metric:
        type: "string"
        enum:
        - "AVG"
        - "MAX"
        - "MIN"
        - "SUM"
        - "CARDINALITY"
        - "SPANNING"
        - "GEOBBOX"
        - "GEOCENTROID"
      value:
        type: "number"
        format: "double"
      geometry:
        $ref: "#/definitions/GeoJsonObject"
  ComputationRequest:
    type: "object"
    properties:
      filter:
        $ref: "#/definitions/Filter"
      form:
        $ref: "#/definitions/Form"
      field:
        type: "string"
      metric:
        type: "string"
        enum:
        - "AVG"
        - "MAX"
        - "MIN"
        - "SUM"
        - "CARDINALITY"
        - "SPANNING"
        - "GEOBBOX"
        - "GEOCENTROID"
  Geo:
    type: "object"
    properties:
      path:
        type: "string"
      geometry:
        $ref: "#/definitions/GeoJsonObject"
  Hit:
    type: "object"
    properties:
      md:
        $ref: "#/definitions/MD"
      data:
        type: "object"
  Hits:
    type: "object"
    properties:
      collection:
        type: "string"
      hits:
        type: "array"
        items:
          $ref: "#/definitions/Hit"
      nbhits:
        type: "integer"
        format: "int64"
      totalnb:
        type: "integer"
        format: "int64"
      links:
        type: "object"
        additionalProperties:
          $ref: "#/definitions/Link"
  Link:
    type: "object"
    required:
    - "href"
    - "method"
    properties:
      href:
        type: "string"
      method:
        type: "string"
      body:
        $ref: "#/definitions/Search"
  MD:
    type: "object"
    properties:
      id:
        type: "string"
      timestamp:
        type: "integer"
        format: "int64"
      geometry:
        $ref: "#/definitions/GeoJsonObject"
      centroid:
        $ref: "#/definitions/GeoJsonObject"
      returned_geometries:
        type: "array"
        items:
          $ref: "#/definitions/Geo"
  Page:
    type: "object"
    properties:
      size:
        type: "integer"
        format: "int32"
      from:
        type: "integer"
        format: "int32"
      sort:
        type: "string"
      after:
        type: "string"
      before:
        type: "string"
  Projection:
    type: "object"
    properties:
      includes:
        type: "string"
      excludes:
        type: "string"
  Search:
    type: "object"
    properties:
      filter:
        $ref: "#/definitions/Filter"
      form:
        $ref: "#/definitions/Form"
      page:
        $ref: "#/definitions/Page"
      projection:
        $ref: "#/definitions/Projection"
      returned_geometries:
        type: "string"
  Count:
    type: "object"
    properties:
      filter:
        $ref: "#/definitions/Filter"
      form:
        $ref: "#/definitions/Form"
  CollectionReferenceDescription:
    type: "object"
    required:
    - "collection_name"
    - "params"
    properties:
      properties:
        type: "object"
        additionalProperties:
          $ref: "#/definitions/CollectionReferenceDescriptionProperty"
      collection_name:
        type: "string"
      params:
        $ref: "#/definitions/CollectionReferenceParameters"
  CollectionReferenceDescriptionProperty:
    type: "object"
    properties:
      type:
        type: "string"
        enum:
        - "TEXT"
        - "KEYWORD"
        - "LONG"
        - "INTEGER"
        - "SHORT"
        - "BYTE"
        - "DOUBLE"
        - "FLOAT"
        - "DATE"
        - "BOOLEAN"
        - "BINARY"
        - "INT_RANGE"
        - "FLOAT_RANGE"
        - "LONG_RANGE"
        - "DOUBLE_RANGE"
        - "DATE_RANGE"
        - "OBJECT"
        - "NESTED"
        - "GEO_POINT"
        - "GEO_SHAPE"
        - "IP"
        - "COMPLETION"
        - "TOKEN_COUNT"
        - "MAPPER_MURMUR3"
        - "UNKNOWN"
      format:
        type: "string"
      properties:
        type: "object"
        additionalProperties:
          $ref: "#/definitions/CollectionReferenceDescriptionProperty"
      taggable:
        type: "boolean"
