---
swagger: "2.0"
info:
  description: "Explore the content of ARLAS collections"
  version: "11.0.3-SNAPSHOT"
  title: "ARLAS Exploration API"
  contact:
    name: "Gisaia"
    url: "http://www.gisaia.com/"
    email: "contact@gisaia.com"
  license:
    name: "Apache 2.0"
    url: "https://www.apache.org/licenses/LICENSE-2.0.html"
basePath: "/arlas"
tags:
- name: "collections"
- name: "explore"
- name: "write"
schemes:
- "http"
- "https"
paths:
  /collections/_export:
    get:
      tags:
      - "collections"
      summary: "Get all collection references as a json file"
      description: "Get all collection references in ARLAS as json file"
      operationId: "exportCollections_1"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters: []
      responses:
        200:
          description: "Successful operation"
          schema:
            type: "array"
            items:
              $ref: "#/definitions/CollectionReference"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
  /collections/_import:
    post:
      tags:
      - "collections"
      summary: "Add collection references from a json file"
      description: "Add collection references in ARLAS from a json file"
      operationId: "importCollections_1"
      consumes:
      - "multipart/form-data"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "file"
        in: "formData"
        required: false
        type: "file"
      responses:
        200:
          description: "Successful operation"
          schema:
            type: "string"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
  /collections:
    get:
      tags:
      - "collections"
      summary: "Get all collection references"
      description: "Get all collection references in ARLAS"
      operationId: "getAll_1"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            type: "array"
            items:
              $ref: "#/definitions/CollectionReference"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
  /collections/{collection}:
    get:
      tags:
      - "collections"
      summary: "Get a collection reference"
      description: "Get a collection reference in ARLAS"
      operationId: "get_1"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/CollectionReference"
        404:
          description: "Collection not found."
          schema:
            $ref: "#/definitions/Error"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
    put:
      tags:
      - "collections"
      summary: "Add a collection reference"
      description: "Add a collection reference in ARLAS"
      operationId: "put_1"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "collectionParams"
        description: "collectionParams"
        required: true
        schema:
          $ref: "#/definitions/CollectionReferenceParameters"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/CollectionReference"
        400:
          description: "JSON parameter malformed."
          schema:
            $ref: "#/definitions/Error"
        404:
          description: "Not Found Error."
          schema:
            $ref: "#/definitions/Error"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
    delete:
      tags:
      - "collections"
      summary: "Delete a collection reference"
      description: "Delete a collection reference in ARLAS"
      operationId: "delete_1"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Success"
        404:
          description: "Collection not found."
          schema:
            $ref: "#/definitions/Error"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_aggregate:
    get:
      tags:
      - "explore"
      summary: "Aggregate"
      description: "Aggregate the elements in the collection(s), given the filters\
        \ and the aggregation parameters"
      operationId: "aggregate"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "agg"
        in: "query"
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}\
          \ \n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n \n   -\
          \ **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types. \n \n   - It's possible\
          \ to apply multiple metric aggregations by defining multiple (**collect_field**,**collect_fct**)\
          \ couples.\n \n   - (**collect_field**,**collect_fct**) couples should be\
          \ unique in that case.\n \n   - (**order**,**on**) couple is optional for\
          \ all aggregation types.\n \n   - **size** is optional for term and geohash,\
          \ and must not be specified for the other types.\n \n   - **include** is\
          \ optional for term, and must not be specified for the other types.\n \n\
          - {type} possible values are : \n \n       datehistogram, histogram, geohash\
          \ and term. \n \n- {interval} possible values depends on {type}. \n \n \
          \      If {type} = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = term, then interval-{interval} is not needed. \n\
          \ \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum\n \n- {order}\
          \ is set to sort the aggregation buckets on the field name, on the count\
          \ of the buckets or on the the result of a metric sub-aggregation. Its values\
          \ are 'asc' or 'desc'. \n \n- {on} is set to specify whether the {order}\
          \ is on the field name, on the count of the aggregation or on the result\
          \ of a metric sub-aggregation. Its values are 'field', 'count' or 'result'.\
          \ \n \n- If {on} is equal to `result` and two or more (**collect_field**,**collect_fct**)\
          \ couples are specified, then the order is applied on the first `collect_fct`\
          \ that is different from geobbox and geocentroid\n \n- {size} Defines how\
          \ many buckets should be returned. \n \n- {include} Specifies the values\
          \ for which buckets will be created. This values are comma separated. If\
          \ one value is specified then regular expressions can be used (only in this\
          \ case) and buckets matching them will be created. If more than one value\
          \ are specified then only buckets matching the exact values will be created.\n\
          \ \n- **fetch_geometry**\n \n    > **What it does**: Specifies the strategy\
          \ of fetching a geometry in each aggregation bucket.\n \n    > __**Syntax**__:\
          \ `fetch_geometry` || `fetch_geometry-{strategy}` || `fetch_geometry-{field}-(first||last)`.\n\
          \ \n    > **fetch_geometry** or **fetch_geometry-byDefault**: the fetched\
          \ geometry is the centroid of the geohash for `geohash` aggregation or a\
          \ random geometry for the rest of aggregation types.\n \n    > **fetch_geometry-centroid**:\
          \ the fetched geometry is the centroid of data inside each bucket.\n \n\
          \    > **fetch_geometry-bbox**: the fetched geometry is the data extend\
          \ (bbox) in each bucket.\n \n    > **fetch_geometry-geohash**: the fetched\
          \ geometry is the 'geohash' extend of each bucket. This strategy is supported\
          \ for **geohash** aggregation type only.\n \n    > **fetch_geometry-first**:\
          \ the fetched geometry is the first hit's geometry fetched in each bucket\
          \ (chronologically)\n \n    > **fetch_geometry-last**: the fetched geometry\
          \ is the first hit's geometry fetched in each bucket (chronologically)\n\
          \ \n    > **fetch_geometry-{field}-first**: the fetched geometry is the\
          \ geometry of the first hit - ordered by the {field} - fetched in each bucket.\n\
          \ \n    > **fetch_geometry-{field}-last**: the fetched geometry is the geometry\
          \ of the first hit - ordered by the {field} - fetched in each bucket.\n\
          \ \n    > **Note 1**: if **fetch_geometry** is specified, the returned geometry\
          \ is set int the 'geometry' attribute of the json response.\n \n    > **Note\
          \ 2**: If **fetch_geometry-centroid** and **collect_fct**=`geocentroid`\
          \ are both set, the centroid of each bucket is only returned in 'geometry'\
          \ attribute of the json response but not in the metrics. Same for **fetch_geometry-bbox**\
          \ and **collect_fct**=`geobbox`\n \n- **fetchHits** \n \n    > **What it\
          \ does**: Specifies the number of hits to retrieve inside each aggregation\
          \ bucket and which fields to include in the hits.\n \n    > __**Syntax**__:\
          \ `fetchHits-{sizeOfHitsToFetch}(+{field1}, {field2}, -{field3}, ...)`.\n\
          \ \n    > **Note 1**: `{sizeOfHitsToFetch}` is optional, if not specified,\
          \ 1 is considered as default.\n \n    > **Note 2**: `{field}` can be preceded\
          \ by **+** or **-** for **ascending** or **descending** sort of the hits.\
          \ Order matters.\n \n    > __**Example**__: `fetchHits-3(-timestamp, geometry)`.\
          \ Fetches the 3 last positions for each bucket.\n \n**agg** parameter is\
          \ multiple. Every agg parameter specified is a subaggregation of the previous\
          \ one : order matters. \n \nFor more details, check https://gitlab.com/GISAIA.ARLAS/ARLAS-server/blob/master/doc/api/API-definition.md."
        required: true
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/AggregationResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "Aggregate"
      description: "Aggregate the elements in the collection(s), given the filters\
        \ and the aggregation parameters"
      operationId: "aggregatePost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/AggregationsRequest"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/AggregationResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_geoaggregate:
    get:
      tags:
      - "explore"
      summary: "GeoAggregate"
      description: "Aggregate the elements in the collection(s) as features, given\
        \ the filters and the aggregation parameters."
      operationId: "geoaggregate"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "agg"
        in: "query"
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:fetcbGeometry-{fetch_geometry\
          \ values}\n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types.\n \n   - (**order**,**on**)\
          \ couple is optional for all aggregation types.\n \n   - **size** is optional\
          \ for term and geohash, and must not be specified for the other types.\n\
          \ \n   - **include** is optional for term, and must not be specified for\
          \ the other types.\n \n- {type} possible values are : \n \n       geohash,\
          \ datehistogram, histogram and term. geohash must be the main aggregation.\n\
          \ \n- {interval} possible values depends on {type}. \n \n       If {type}\
          \ = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = term, then interval-{interval} is not needed. \n\
          \ \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum,geobbox,geocentroid\n\
          \ \n- (collect_field,collect_fct) should both be specified, except when\
          \ collect_fct = `geobbox` or `geocentroid`, it could be specified alone.\
          \ The metrics `geobbox` and `geocentroid` are returned as features collections.\n\
          \ \n- {order} is set to sort the aggregation buckets on the field name,\
          \ on the count of the buckets or on the the result of a metric sub-aggregation.\
          \ Its values are 'asc' or 'desc'. \n \n- {on} is set to specify whether\
          \ the {order} is on the field name, on the count of the aggregation or on\
          \ the result of a metric sub-aggregation. Its values are 'field', 'count'\
          \ or 'result'. \n \n- When {on} = `result`, then (collect_field,collect_fct)\
          \ should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`,\
          \ then {on}=`result` is prohibited\n \n- {size} Defines how many buckets\
          \ should be returned. \n \n- {include} Specifies the values for which buckets\
          \ will be created. This values are comma separated. If one value is specified\
          \ then regular expressions can be used (only in this case) and buckets matching\
          \ them will be created. If more than one value are specified then only buckets\
          \ matching the exact values will be created.\n \n- **fetch_geometry**\n\
          \ \n    > **What it does**: Specifies the strategy of fetching a geometry\
          \ in each aggregation bucket.\n \n    > __**Syntax**__: `fetch_geometry`\
          \ || `fetch_geometry-{strategy}` || `fetch_geometry-{field}-(first||last)`.\n\
          \ \n    > **fetch_geometry** or **fetch_geometry-byDefault**: the fetched\
          \ geometry is the centroid of the geohash for `geohash` aggregation or a\
          \ random geometry for the rest of aggregation types.\n \n    > **fetch_geometry-centroid**:\
          \ the fetched geometry is the centroid of data inside each bucket.\n \n\
          \    > **fetch_geometry-bbox**: the fetched geometry is the data extend\
          \ (bbox) in each bucket.\n \n    > **fetch_geometry-geohash**: the fetched\
          \ geometry is the 'geohash' extend of each bucket. This strategy is supported\
          \ for **geohash** aggregation type only.\n \n    > **fetch_geometry-first**:\
          \ the fetched geometry is the first hit's geometry fetched in each bucket\
          \ (chronologically)\n \n    > **fetch_geometry-last**: the fetched geometry\
          \ is the first hit's geometry fetched in each bucket (chronologically)\n\
          \ \n    > **fetch_geometry-{field}-first**: the fetched geometry is the\
          \ geometry of the first hit - ordered by the {field} - fetched in each bucket.\n\
          \ \n    > **fetch_geometry-{field}-last**: the fetched geometry is the geometry\
          \ of the first hit - ordered by the {field} - fetched in each bucket.\n\
          \ \n    > **Note 1**: if **fetch_geometry** is specified, the returned geometry\
          \ is set int the 'geometry' attribute of the geojson.\n \n    > **Note 2**:\
          \ If **fetch_geometry-centroid** and **collect_fct**=`geocentroid` are both\
          \ set, the centroid of each bucket is only returned in the geojson 'geometry'\
          \ attribute but not in the metrics. Same for **fetch_geometry-bbox** and\
          \ **collect_fct**=`geobbox`\n \n- **fetch_hits** \n \n    > **What it does**:\
          \ Specifies the number of hits to retrieve inside each aggregation bucket\
          \ and which fields to include in the hits.\n \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1},\
          \ {field2}, -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}`\
          \ is optional, if not specified, 1 is considered as default.\n \n    > **Note\
          \ 2**: `{field}` can be preceded by **+** or **-** for **ascending** or\
          \ **descending** sort of the hits. Order matters.\n \n    > __**Example**__:\
          \ `fetch_hits-3(-timestamp, geometry)`. Fetches the 3 last positions for\
          \ each bucket.\n \n**agg** parameter is multiple. The first (main) aggregation\
          \ must be geohash. Every agg parameter specified is a subaggregation of\
          \ the previous one : order matters. \n \nFor more details, check https://github.com/gisaia/ARLAS-server/blob/master/docs/arlas-api-exploration.md "
        required: true
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
        501:
          description: "Not implemented functionality."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "GeoAggregate"
      description: "Aggregate the elements in the collection(s) as features, given\
        \ the filters and the aggregation parameters."
      operationId: "geoaggregatePost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/AggregationsRequest"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
        501:
          description: "Not implemented functionality."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_geoaggregate/{geohash}:
    get:
      tags:
      - "explore"
      summary: "GeoAggregate on a geohash"
      description: "Aggregate the elements in the collection(s) and localized in the\
        \ given geohash as features, given the filters and the aggregation parameters."
      operationId: "geohashgeoaggregate"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "geohash"
        in: "path"
        description: "geohash"
        required: true
        type: "string"
      - name: "agg"
        in: "query"
        description: "- The agg parameter should be given in the following formats:\
          \  \n \n       {type}:{field}:interval-{interval}:format-{format}:collect_field-{collect_field}:collect_fct-{function}:order-{order}:on-{on}:size-{size}:fetcbGeometry-{fetch_geometry\
          \ values}\n \nWhere :\n \n   - **{type}:{field}** part is mandatory. \n\
          \ \n   - **interval** must be specified only when aggregation type is datehistogram,\
          \ histogram and geohash.\n \n   - **format** is optional for datehistogram,\
          \ and must not be specified for the other types.\n \n   - (**collect_field**,**collect_fct**)\
          \ couple is optional for all aggregation types.\n \n   - (**order**,**on**)\
          \ couple is optional for all aggregation types.\n \n   - **size** is optional\
          \ for term and geohash, and must not be specified for the other types.\n\
          \ \n   - **include** is optional for term, and must not be specified for\
          \ the other types.\n \n- {type} possible values are : \n \n       geohash,\
          \ datehistogram, histogram and term. geohash must be the main aggregation.\n\
          \ \n- {interval} possible values depends on {type}. \n \n       If {type}\
          \ = datehistogram, then {interval} = {size}(year,quarter,month,week,day,hour,minute,second).\
          \ Size value must be equal to 1 for year,quarter,month and week unities.\
          \ \n \n       If {type} = histogram, then {interval} = {size}. \n \n   \
          \    If {type} = geohash, then {interval} = {size}. It's an integer between\
          \ 1 and 12. Lower the length, greater is the surface of aggregation. \n\
          \ \n       If {type} = term, then interval-{interval} is not needed. \n\
          \ \n- format-{format} is the date format for key aggregation. The default\
          \ value is yyyy-MM-dd-hh:mm:ss.\n \n- {collect_fct} is the aggregation function\
          \ to apply to collections on the specified {collect_field}. \n \n  {collect_fct}\
          \ possible values are : \n \n       avg,cardinality,max,min,sum,geobbox,geocentroid\n\
          \ \n- (collect_field,collect_fct) should both be specified, except when\
          \ collect_fct = `geobbox` or `geocentroid`, it could be specified alone.\
          \ The metrics `geobbox` and `geocentroid` are returned as features collections.\n\
          \ \n- {order} is set to sort the aggregation buckets on the field name,\
          \ on the count of the buckets or on the the result of a metric sub-aggregation.\
          \ Its values are 'asc' or 'desc'. \n \n- {on} is set to specify whether\
          \ the {order} is on the field name, on the count of the aggregation or on\
          \ the result of a metric sub-aggregation. Its values are 'field', 'count'\
          \ or 'result'. \n \n- When {on} = `result`, then (collect_field,collect_fct)\
          \ should be specified. Except when {collect_fct} = `geobbox` or `geocentroid`,\
          \ then {on}=`result` is prohibited\n \n- {size} Defines how many buckets\
          \ should be returned. \n \n- {include} Specifies the values for which buckets\
          \ will be created. This values are comma separated. If one value is specified\
          \ then regular expressions can be used (only in this case) and buckets matching\
          \ them will be created. If more than one value are specified then only buckets\
          \ matching the exact values will be created.\n \n- **fetch_geometry**\n\
          \ \n    > **What it does**: Specifies the strategy of fetching a geometry\
          \ in each aggregation bucket.\n \n    > __**Syntax**__: `fetch_geometry`\
          \ || `fetch_geometry-{strategy}` || `fetch_geometry-{field}-(first||last)`.\n\
          \ \n    > **fetch_geometry** or **fetch_geometry-byDefault**: the fetched\
          \ geometry is the centroid of the geohash for `geohash` aggregation or a\
          \ random geometry for the rest of aggregation types.\n \n    > **fetch_geometry-centroid**:\
          \ the fetched geometry is the centroid of data inside each bucket.\n \n\
          \    > **fetch_geometry-bbox**: the fetched geometry is the data extend\
          \ (bbox) in each bucket.\n \n    > **fetch_geometry-geohash**: the fetched\
          \ geometry is the 'geohash' extend of each bucket. This strategy is supported\
          \ for **geohash** aggregation type only.\n \n    > **fetch_geometry-first**:\
          \ the fetched geometry is the first hit's geometry fetched in each bucket\
          \ (chronologically)\n \n    > **fetch_geometry-last**: the fetched geometry\
          \ is the first hit's geometry fetched in each bucket (chronologically)\n\
          \ \n    > **fetch_geometry-{field}-first**: the fetched geometry is the\
          \ geometry of the first hit - ordered by the {field} - fetched in each bucket.\n\
          \ \n    > **fetch_geometry-{field}-last**: the fetched geometry is the geometry\
          \ of the first hit - ordered by the {field} - fetched in each bucket.\n\
          \ \n    > **Note 1**: if **fetch_geometry** is specified, the returned geometry\
          \ is set int the 'geometry' attribute of the geojson.\n \n    > **Note 2**:\
          \ If **fetch_geometry-centroid** and **collect_fct**=`geocentroid` are both\
          \ set, the centroid of each bucket is only returned in the geojson 'geometry'\
          \ attribute but not in the metrics. Same for **fetch_geometry-bbox** and\
          \ **collect_fct**=`geobbox`\n \n- **fetch_hits** \n \n    > **What it does**:\
          \ Specifies the number of hits to retrieve inside each aggregation bucket\
          \ and which fields to include in the hits.\n \n    > __**Syntax**__: `fetch_hits-{sizeOfHitsToFetch}(+{field1},\
          \ {field2}, -{field3}, ...)`.\n \n    > **Note 1**: `{sizeOfHitsToFetch}`\
          \ is optional, if not specified, 1 is considered as default.\n \n    > **Note\
          \ 2**: `{field}` can be preceded by **+** or **-** for **ascending** or\
          \ **descending** sort of the hits. Order matters.\n \n    > __**Example**__:\
          \ `fetch_hits-3(-timestamp, geometry)`. Fetches the 3 last positions for\
          \ each bucket.\n \n**agg** parameter is multiple. The first (main) aggregation\
          \ must be geohash. Every agg parameter specified is a subaggregation of\
          \ the previous one : order matters. \n \nFor more details, check https://github.com/gisaia/ARLAS-server/blob/master/docs/arlas-api-exploration.md "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
        501:
          description: "Not implemented functionality."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_count:
    get:
      tags:
      - "explore"
      summary: "Count"
      description: "Count the number of elements found in the collection(s), given\
        \ the filters"
      operationId: "count"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collections"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hits"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "Count"
      description: "Count the number of elements found in the collection(s), given\
        \ the filters"
      operationId: "countPost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collections"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/Count"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hits"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_describe:
    get:
      tags:
      - "explore"
      summary: "Describe"
      description: "Describe the structure and the content of the given collection. "
      operationId: "describe"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/CollectionReferenceDescription"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/_list:
    get:
      tags:
      - "explore"
      summary: "List"
      description: "List the collections configured in ARLAS. "
      operationId: "list"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/CollectionReferenceDescription"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/ogc/opensearch/{collection}:
    get:
      tags:
      - "explore"
      summary: "OpenSearch Description Document"
      description: "Access to the OpenSearch Description document for the given collection"
      operationId: "opensearch"
      produces:
      - "application/xml"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_range:
    get:
      tags:
      - "explore"
      summary: "RangeRequest"
      description: "Calculates the min and max values of a field in the collection,\
        \ given the filters"
      operationId: "range"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "field"
        in: "query"
        description: "The field whose range is calculated"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/RangeResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "Aggregate"
      description: "Calculates the min and max values of a field in the collection,\
        \ given the filters"
      operationId: "rangePost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/RangeRequest"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/RangeResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/{identifier}:
    get:
      tags:
      - "explore"
      summary: "Get an Arlas document"
      description: "Returns a raw indexed document."
      operationId: "getArlasHit"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "identifier"
        in: "path"
        description: "identifier"
        required: true
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hit"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
        404:
          description: "Not Found Error."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_geosearch/{z}/{x}/{y}:
    get:
      tags:
      - "explore"
      summary: "Tiled GeoSearch"
      description: "Search and return the elements found in the collection(s) and\
        \ localized in the given tile(x,y,z) as features, given the filters"
      operationId: "tiledgeosearch"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "x"
        in: "path"
        description: "x"
        required: true
        type: "integer"
        format: "int32"
      - name: "y"
        in: "path"
        description: "y"
        required: true
        type: "integer"
        format: "int32"
      - name: "z"
        in: "path"
        description: "z"
        required: true
        type: "integer"
        format: "int32"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "include"
        in: "query"
        description: "List the name patterns of the field to be included in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
          default: "*"
        collectionFormat: "multi"
      - name: "exclude"
        in: "query"
        description: "List the name patterns of the field to be excluded in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 0
      - name: "sort"
        in: "query"
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "after"
        in: "query"
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        required: false
        type: "string"
      - name: "before"
        in: "query"
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        required: false
        type: "string"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_geosearch:
    get:
      tags:
      - "explore"
      summary: "GeoSearch"
      description: "Search and return the elements found in the collection(s) as features,\
        \ given the filters"
      operationId: "geosearch"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "include"
        in: "query"
        description: "List the name patterns of the field to be included in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
          default: "*"
        collectionFormat: "multi"
      - name: "exclude"
        in: "query"
        description: "List the name patterns of the field to be excluded in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 0
      - name: "sort"
        in: "query"
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "after"
        in: "query"
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        required: false
        type: "string"
      - name: "before"
        in: "query"
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        required: false
        type: "string"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "GeoSearch"
      description: "Search and return the elements found in the collection(s) as features,\
        \ given the filters"
      operationId: "geosearchPost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/Search"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/FeatureCollection"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collection}/_search:
    get:
      tags:
      - "explore"
      summary: "Search"
      description: "Search and return the elements found in the collection, given\
        \ the filters"
      operationId: "search"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      - "application/atom+xml"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "flat"
        in: "query"
        description: "Flats the property map: only key/value on one level"
        required: false
        type: "boolean"
        default: false
      - name: "include"
        in: "query"
        description: "List the name patterns of the field to be included in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
          default: "*"
        collectionFormat: "multi"
      - name: "exclude"
        in: "query"
        description: "List the name patterns of the field to be excluded in the result.\
          \ Separate patterns with a comma."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 0
      - name: "sort"
        in: "query"
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        required: false
        type: "string"
      - name: "after"
        in: "query"
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        required: false
        type: "string"
      - name: "before"
        in: "query"
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        required: false
        type: "string"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hits"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
    post:
      tags:
      - "explore"
      summary: "Search"
      description: "Search and return the elements found in the collection, given\
        \ the filters"
      operationId: "searchPost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/Search"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/Hits"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /explore/{collections}/_suggest:
    get:
      tags:
      - "explore"
      summary: "Suggest"
      description: "Suggest the the n (n=size) most relevant terms given the filters"
      operationId: "suggest"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collections"
        in: "path"
        description: "collections, comma separated"
        required: true
        type: "string"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided. The order does not matter. \n \n- A triplet is composed of a\
          \ field name, a comparison operator and a value. \n \n  The possible values\
          \ of the comparison operator are : \n \n       Operator   |            \
          \       Description                      | value type\n \n       :     \
          \     |  {fieldName} equals {value}                        | numeric or\
          \ strings \n \n       :gte:      |  {fieldName} is greater than or equal\
          \ to  {value}  | numeric \n \n       :gt:       |  {fieldName} is greater\
          \ than {value}               | numeric \n \n       :lte:      |  {fieldName}\
          \ is less than or equal to {value}      | numeric \n \n       :lt:     \
          \  |  {fieldName}  is less than {value}                 | numeric \n \n\n\
          \ \n- The AND operator is applied between filters having different fieldNames.\
          \ \n \n- The OR operator is applied on filters having the same fieldName.\
          \ \n \n- If the fieldName starts with - then a must not filter is used\n\
          \ \n- If the fieldName starts with - then a must not filter is used\n \n\
          For more details, check https://gitlab.com/GISAIA.ARLAS/ARLAS-server/blob/master/doc/api/API-definition.md "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search"
        required: false
        type: "string"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given geometry\
          \ (WKT)"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given geometry\
          \ (WKT)"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given geometry\
          \ (WKT)"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given geometry (WKT)"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry (WKT)"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given geometry\
          \ (WKT)"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
        format: "int32"
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 1
        format: "int32"
      - name: "field"
        in: "query"
        description: "Name of the field to be used for retrieving the most relevant\
          \ terms"
        required: false
        type: "string"
        default: "_all"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
  /explore/{collection}/_tile/{z}/{x}/{y}.png:
    get:
      tags:
      - "explore"
      summary: "Tiled GeoSearch"
      description: "Search and return the elements found in the collection(s) and\
        \ localized in the given tile(x,y,z) as features, given the filters"
      operationId: "tiledgeosearch_1"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "image/png"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - name: "x"
        in: "path"
        description: "x"
        required: true
        type: "integer"
        format: "int32"
      - name: "y"
        in: "path"
        description: "y"
        required: true
        type: "integer"
        format: "int32"
      - name: "z"
        in: "path"
        description: "z"
        required: true
        type: "integer"
        format: "int32"
      - name: "f"
        in: "query"
        description: "- A triplet for filtering the result. Multiple filter can be\
          \ provided in distinct parameters (AND operator is applied) or in the same\
          \ parameter separated by semi-colons (OR operator is applied). The order\
          \ does not matter. \n \n- A triplet is composed of a field name, a comparison\
          \ operator and a value. \n \n  The possible values of the comparison operator\
          \ are : \n \n       Operator |                   Description           \
          \         | value type\n \n       :eq:     | {fieldName} equals {comma separated\
          \ values}. **OR** operation is applied for the specified values | numeric\
          \ or strings \n \n       :ne:     | {fieldName} must not equal {comma separated\
          \ values }. **AND** operation is applied for the specified values | numeric\
          \ or strings \n \n       :like:   | {fieldName}  is like {value}       \
          \              | numeric or strings \n \n       :gte:    | {fieldName} is\
          \ greater than or equal to  {value} | numeric \n \n       :gt:     | {fieldName}\
          \ is greater than {value}              | numeric \n \n       :lte:    |\
          \ {fieldName} is less than or equal to {value}     | numeric \n \n     \
          \  :lt:     | {fieldName}  is less than {value}                | numeric\
          \ \n \n       :range:  | {fieldName} is between `{comma separated [min<max]\
          \ values}`. **OR** operation is applied for the specified ranges | numeric\
          \ or strings. If the field's type is date, then min & max should be timestamps\
          \ in millisecond or a Date expression"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "q"
        in: "query"
        description: "A full text search. Optionally, it's possible to search on a\
          \ field using this syntax: {fieldname}:{text}"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "pwithin"
        in: "query"
        description: "Any element having its centroid contained within the given WKT\
          \ Polygon or MultiPolygon (clock-wise) or the given BBOX : `west, south,\
          \ east, north`. "
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gwithin"
        in: "query"
        description: "Any element having its geometry contained within the given WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "gintersect"
        in: "query"
        description: "Any element having its geometry intersecting the given WKT string\
          \ (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notpwithin"
        in: "query"
        description: "Any element having its centroid outside the given WKT Polygon\
          \ or MultiPolygon (clock-wise) or the given BBOX : `west, south, east, north`."
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgwithin"
        in: "query"
        description: "Any element having its geometry outside the given geometry WKT\
          \ string (clock-wise) or the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "notgintersect"
        in: "query"
        description: "Any element having its geometry not intersecting the given WKT\
          \ string (clock-wise) nor the given BBOX : `west, south, east, north`"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "dateformat"
        in: "query"
        description: "The format of dates. This parameter should be set only if a\
          \ date field is queried in `f` param; when using `gt`, `lt`, `gte`, `lte`\
          \ and `range` operations"
        required: false
        type: "string"
      - name: "size"
        in: "query"
        description: "The maximum number of entries or sub-entries to be returned.\
          \ The default value is 10"
        required: false
        type: "integer"
        default: 10
        minimum: 1
      - name: "from"
        in: "query"
        description: "From index to start the search from. Defaults to 0."
        required: false
        type: "integer"
        default: 0
        minimum: 0
      - name: "sort"
        in: "query"
        description: "Sorts the resulted hits on the given fields and/or by distance\
          \ to a given point:\n \n> __**Syntax**__: `{field1},{field2},-{field3},geodistance:{lat}\
          \ {lon},{field4}  ...`.\n \n> **Note 1**: `{field}` can be preceded by **'-'**\
          \  for **descending** sort. By default, sort is ascending.\n \n> **Note\
          \ 2**: The order of fields matters.\n \n> **Note 3** ***geodistance sort***:\
          \ Sorts the hits centroids by distance to the given **{lat} {lon}** (ascending\
          \ distance sort). It can be specified at most 1 time.\n \n> __**Example\
          \ 1**__: sort=`age,-timestamp`. Resulted hits are sorted by age. For same\
          \ age hits, they are decreasingly sorted in time.\n \n> __**Example 2**__:\
          \ sort=`age,geodistance:89 179`. Resulted hits are sorted by age. For same\
          \ age hits, they are sorted by closest distance to the point(89,179)\n\
          \ \n"
        required: false
        type: "array"
        items:
          type: "string"
        collectionFormat: "multi"
      - name: "after"
        in: "query"
        description: "List of values of fields present in sort param that are used\
          \ to search after. \n \n> **What it does**: Retrieve the data placed after\
          \ the pointed element, given the provided order (sort).\n \n> __**Restriction\
          \ 1**__: **after** param works only combined with **sort** param.\n \n>\
          \ __**Syntax**__: `after={value1},{value2},...,{valueN} & sort={field1},{field2},...,{fieldN}`.\n\
          \ \n> **Note 1**: *{value1}` and `{value2}` are the values of `{field1}`\
          \ and `{field2}` in the last hit returned in the previous search\n \n> **Note\
          \ 2**: The order of fields and values matters. *{value1},{value2}* must\
          \ be in the same order of *{field1},{field2}* in **sort** param\n \n> **Note\
          \ 3**:  The last field `{fieldN}` must be the id field specified in the\
          \ collection **collection.params.idPath** (returned as **md.id**) and `{valueN}`\
          \ its corresponding value.\n \n> __**Example**__: *sort=`-date,id` & **after**=`01/02/2019,abcd1234`*.\
          \ Gets the following hits of the previous search that stopped at date *01/02/2019*\
          \ and id *abcd1234*.\n \n> __**Restriction 2**__: **from** param must be\
          \ set to 0 or kept unset\n \n"
        required: false
        type: "string"
      - name: "before"
        in: "query"
        description: "Same idea that after param, but to retrieve the data placed\
          \ before the pointed element, given the provided order (sort)."
        required: false
        type: "string"
      - name: "sampling"
        in: "query"
        description: "Size of the sampling for testing transparency: 1: test every\
          \ pixel, 10: test 1 pixel every 10 pixels, etc."
        required: false
        type: "integer"
        default: 10
        format: "int32"
      - name: "coverage"
        in: "query"
        description: "Percentage (]0-100]) of acceptable transparent pixels. Higher\
          \ the percentage, more tiles could be used for filling the tile"
        required: false
        type: "integer"
        default: 70
        format: "int32"
      - name: "max-age-cache"
        in: "query"
        description: "max-age-cache"
        required: false
        type: "integer"
        format: "int32"
      responses:
        200:
          description: "Successful operation"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
  /write/{collection}/_untag:
    post:
      tags:
      - "write"
      summary: "Untag"
      description: "Search and untag the elements found in the collection, given the\
        \ filters (Deprecated)"
      operationId: "untagPost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/TagRequest"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/UpdateResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
      deprecated: true
  /write/{collection}/_tag:
    post:
      tags:
      - "write"
      summary: "Tag"
      description: "Search and tag the elements found in the collection, given the\
        \ filters (Deprecated)"
      operationId: "tagPost"
      consumes:
      - "application/json;charset=utf-8"
      produces:
      - "application/json;charset=utf-8"
      parameters:
      - name: "collection"
        in: "path"
        description: "collection"
        required: true
        type: "string"
      - in: "body"
        name: "body"
        required: false
        schema:
          $ref: "#/definitions/TagRequest"
      - name: "pretty"
        in: "query"
        description: "Pretty print"
        required: false
        type: "boolean"
        default: false
      responses:
        200:
          description: "Successful operation"
          schema:
            $ref: "#/definitions/UpdateResponse"
        500:
          description: "Arlas Server Error."
          schema:
            $ref: "#/definitions/Error"
        400:
          description: "Bad request."
          schema:
            $ref: "#/definitions/Error"
      deprecated: true
definitions:
  Bbox:
    type: "object"
    required:
    - "east"
    - "north"
    - "south"
    - "west"
    properties:
      north:
        type: "number"
        format: "double"
      south:
        type: "number"
        format: "double"
      east:
        type: "number"
        format: "double"
      west:
        type: "number"
        format: "double"
  CollectionReference:
    type: "object"
    required:
    - "collection_name"
    - "params"
    properties:
      collection_name:
        type: "string"
      params:
        $ref: "#/definitions/CollectionReferenceParameters"
  CollectionReferenceParameters:
    type: "object"
    required:
    - "centroid_path"
    - "geometry_path"
    - "id_path"
    - "index_name"
    - "timestamp_path"
    properties:
      index_name:
        type: "string"
      type_name:
        type: "string"
      id_path:
        type: "string"
      geometry_path:
        type: "string"
      centroid_path:
        type: "string"
      timestamp_path:
        type: "string"
      exclude_fields:
        type: "string"
      update_max_hits:
        type: "integer"
        format: "int32"
      taggable_fields:
        type: "string"
      exclude_wfs_fields:
        type: "string"
      custom_params:
        type: "object"
        additionalProperties:
          type: "string"
      atom_feed:
        $ref: "#/definitions/Feed"
      open_search:
        $ref: "#/definitions/OpenSearch"
      inspire:
        $ref: "#/definitions/Inspire"
      dublin_core_element_name:
        $ref: "#/definitions/DublinCoreElementName"
      raster_tile_url:
        $ref: "#/definitions/RasterTileURL"
      raster_tile_width:
        type: "integer"
        format: "int32"
      raster_tile_height:
        type: "integer"
        format: "int32"
      filter:
        $ref: "#/definitions/Filter"
  DublinCoreElementName:
    type: "object"
    properties:
      title:
        type: "string"
      creator:
        type: "string"
      subject:
        type: "string"
      description:
        type: "string"
      publisher:
        type: "string"
      contributor:
        type: "string"
      type:
        type: "string"
      format:
        type: "string"
      identifier:
        type: "string"
      source:
        type: "string"
      language:
        type: "string"
      bbox:
        $ref: "#/definitions/Bbox"
      date:
        type: "string"
      coverage:
        type: "object"
        additionalProperties:
          type: "object"
      coverage_centroid:
        type: "string"
  Expression:
    type: "object"
    properties:
      field:
        type: "string"
      op:
        type: "string"
        enum:
        - "eq"
        - "gte"
        - "gt"
        - "lte"
        - "lt"
        - "like"
        - "ne"
        - "range"
      value:
        type: "string"
  Feed:
    type: "object"
    properties:
      author:
        $ref: "#/definitions/Person"
      contributor:
        $ref: "#/definitions/Person"
      icon:
        type: "string"
      logo:
        type: "string"
      rights:
        type: "string"
      subtitle:
        type: "string"
      generator:
        $ref: "#/definitions/Generator"
  Filter:
    type: "object"
    properties:
      f:
        type: "array"
        items:
          type: "array"
          items:
            $ref: "#/definitions/Expression"
      q:
        type: "array"
        items:
          type: "array"
          items:
            type: "string"
      pwithin:
        type: "array"
        items:
          type: "array"
          items:
            type: "string"
      gwithin:
        type: "array"
        items:
          type: "array"
          items:
            type: "string"
      gintersect:
        type: "array"
        items:
          type: "array"
          items:
            type: "string"
      notpwithin:
        type: "array"
        items:
          type: "array"
          items:
            type: "string"
      notgwithin:
        type: "array"
        items:
          type: "array"
          items:
            type: "string"
      notgintersect:
        type: "array"
        items:
          type: "array"
          items:
            type: "string"
      dateformat:
        type: "string"
  Generator:
    type: "object"
    properties:
      name:
        type: "string"
      version:
        type: "string"
      uri:
        type: "string"
  Inspire:
    type: "object"
    properties:
      keywords:
        type: "array"
        items:
          $ref: "#/definitions/Keyword"
      topic_categories:
        type: "array"
        items:
          type: "string"
      lineage:
        type: "string"
      languages:
        type: "array"
        items:
          type: "string"
      spatial_resolution:
        $ref: "#/definitions/InspireSpatialResolution"
      inspire_uri:
        $ref: "#/definitions/InspireURI"
      inspire_limitation_access:
        $ref: "#/definitions/InspireLimitationAccess"
      inspire_use_conditions:
        type: "string"
  InspireLimitationAccess:
    type: "object"
    properties:
      access_constraints:
        type: "string"
      other_constraints:
        type: "string"
      classification:
        type: "string"
  InspireSpatialResolution:
    type: "object"
    properties:
      value:
        $ref: "#/definitions/Number"
      unit_of_measure:
        type: "string"
  InspireURI:
    type: "object"
    properties:
      code:
        type: "string"
      namespace:
        type: "string"
  Keyword:
    type: "object"
    properties:
      value:
        type: "string"
      vocabulary:
        type: "string"
      date_of_publication:
        type: "string"
  Number:
    type: "object"
  OpenSearch:
    type: "object"
    properties:
      short_name:
        type: "string"
      description:
        type: "string"
      contact:
        type: "string"
      tags:
        type: "string"
      long_name:
        type: "string"
      image_height:
        type: "string"
      image_width:
        type: "string"
      image_type:
        type: "string"
      image_url:
        type: "string"
      developer:
        type: "string"
      attribution:
        type: "string"
      syndication_right:
        type: "string"
      adult_content:
        type: "string"
      language:
        type: "string"
      input_encoding:
        type: "string"
      output_encoding:
        type: "string"
  Person:
    type: "object"
    properties:
      name:
        type: "string"
      email:
        type: "string"
      uri:
        type: "string"
  RasterTileURL:
    type: "object"
    required:
    - "id_path"
    - "url"
    properties:
      url:
        type: "string"
      id_path:
        type: "string"
      min_z:
        type: "integer"
        format: "int32"
      max_z:
        type: "integer"
        format: "int32"
      check_geometry:
        type: "boolean"
  Error:
    type: "object"
    properties:
      status:
        type: "integer"
        format: "int32"
      message:
        type: "string"
      error:
        type: "string"
  Success:
    type: "object"
    properties:
      status:
        type: "integer"
        format: "int32"
      message:
        type: "string"
  AggregationMetric:
    type: "object"
    properties:
      type:
        type: "string"
      field:
        type: "string"
      value:
        type: "object"
  AggregationResponse:
    type: "object"
    properties:
      query_time:
        type: "integer"
        format: "int64"
      total_time:
        type: "integer"
        format: "int64"
      totalnb:
        type: "integer"
        format: "int64"
      name:
        type: "string"
      count:
        type: "integer"
        format: "int64"
      sumotherdoccounts:
        type: "integer"
        format: "int64"
      key:
        type: "object"
      key_as_string:
        type: "object"
      elements:
        type: "array"
        items:
          $ref: "#/definitions/AggregationResponse"
      metrics:
        type: "array"
        items:
          $ref: "#/definitions/AggregationMetric"
      hits:
        type: "array"
        items:
          type: "object"
      geometry:
        $ref: "#/definitions/GeoJsonObject"
      flattened_elements:
        type: "object"
        additionalProperties:
          type: "object"
  Crs:
    type: "object"
    properties:
      type:
        type: "string"
        enum:
        - "name"
        - "link"
      properties:
        type: "object"
        additionalProperties:
          type: "object"
  Feature:
    type: "object"
    properties:
      crs:
        $ref: "#/definitions/Crs"
      bbox:
        type: "array"
        items:
          type: "number"
          format: "double"
      properties:
        type: "object"
        additionalProperties:
          type: "object"
      geometry:
        $ref: "#/definitions/GeoJsonObject"
      id:
        type: "string"
  FeatureCollection:
    type: "object"
    properties:
      crs:
        $ref: "#/definitions/Crs"
      bbox:
        type: "array"
        items:
          type: "number"
          format: "double"
      features:
        type: "array"
        items:
          $ref: "#/definitions/Feature"
  GeoJsonObject:
    type: "object"
    discriminator: "type"
    properties:
      crs:
        $ref: "#/definitions/Crs"
      bbox:
        type: "array"
        items:
          type: "number"
          format: "double"
  GeometryCollection:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        geometries:
          type: "array"
          items:
            $ref: "#/definitions/GeoJsonObject"
  LineString:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            $ref: "#/definitions/LngLatAlt"
  LngLatAlt:
    type: "object"
  MultiLineString:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            type: "array"
            items:
              $ref: "#/definitions/LngLatAlt"
  MultiPoint:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            $ref: "#/definitions/LngLatAlt"
  MultiPolygon:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            type: "array"
            items:
              type: "array"
              items:
                $ref: "#/definitions/LngLatAlt"
  Point:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          $ref: "#/definitions/LngLatAlt"
  Polygon:
    allOf:
    - $ref: "#/definitions/GeoJsonObject"
    - type: "object"
      properties:
        coordinates:
          type: "array"
          items:
            type: "array"
            items:
              $ref: "#/definitions/LngLatAlt"
  AggregatedGeometry:
    type: "object"
    properties:
      strategy:
        type: "string"
        enum:
        - "bbox"
        - "centroid"
        - "geohash"
        - "first"
        - "last"
        - "byDefault"
      field:
        type: "string"
  Aggregation:
    type: "object"
    properties:
      type:
        type: "string"
        enum:
        - "datehistogram"
        - "geohash"
        - "histogram"
        - "term"
      field:
        type: "string"
      interval:
        $ref: "#/definitions/Interval"
      format:
        type: "string"
      metrics:
        type: "array"
        items:
          $ref: "#/definitions/Metric"
      order:
        type: "string"
        enum:
        - "asc"
        - "desc"
      on:
        type: "string"
        enum:
        - "field"
        - "count"
        - "result"
      size:
        type: "string"
      include:
        type: "string"
      fetch_geometry:
        $ref: "#/definitions/AggregatedGeometry"
      fetch_hits:
        $ref: "#/definitions/HitsFetcher"
  AggregationsRequest:
    type: "object"
    properties:
      filter:
        $ref: "#/definitions/Filter"
      form:
        $ref: "#/definitions/Form"
      aggregations:
        type: "array"
        items:
          $ref: "#/definitions/Aggregation"
  Form:
    type: "object"
    properties:
      pretty:
        type: "boolean"
      flat:
        type: "boolean"
  HitsFetcher:
    type: "object"
    properties:
      size:
        type: "integer"
        format: "int32"
      include:
        type: "array"
        items:
          type: "string"
  Interval:
    type: "object"
    properties:
      value:
        $ref: "#/definitions/Number"
      unit:
        type: "string"
        enum:
        - "year"
        - "quarter"
        - "month"
        - "week"
        - "day"
        - "hour"
        - "minute"
        - "second"
  Metric:
    type: "object"
    properties:
      collect_field:
        type: "string"
      collect_fct:
        type: "string"
        enum:
        - "AVG"
        - "CARDINALITY"
        - "MAX"
        - "MIN"
        - "SUM"
        - "GEOCENTROID"
        - "GEOBBOX"
  Hit:
    type: "object"
    properties:
      md:
        $ref: "#/definitions/MD"
      data:
        type: "object"
  Hits:
    type: "object"
    properties:
      collection:
        type: "string"
      hits:
        type: "array"
        items:
          $ref: "#/definitions/Hit"
      nbhits:
        type: "integer"
        format: "int64"
      totalnb:
        type: "integer"
        format: "int64"
      links:
        type: "object"
        additionalProperties:
          $ref: "#/definitions/Link"
  Link:
    type: "object"
    required:
    - "href"
    - "method"
    properties:
      href:
        type: "string"
      method:
        type: "string"
      body:
        $ref: "#/definitions/Search"
  MD:
    type: "object"
    properties:
      id:
        type: "string"
      timestamp:
        type: "integer"
        format: "int64"
      geometry:
        $ref: "#/definitions/GeoJsonObject"
      centroid:
        $ref: "#/definitions/GeoJsonObject"
  Page:
    type: "object"
    properties:
      size:
        type: "integer"
        format: "int32"
      from:
        type: "integer"
        format: "int32"
      sort:
        type: "string"
      after:
        type: "string"
      before:
        type: "string"
  Projection:
    type: "object"
    properties:
      includes:
        type: "string"
      excludes:
        type: "string"
  Search:
    type: "object"
    properties:
      filter:
        $ref: "#/definitions/Filter"
      form:
        $ref: "#/definitions/Form"
      page:
        $ref: "#/definitions/Page"
      projection:
        $ref: "#/definitions/Projection"
  Count:
    type: "object"
    properties:
      filter:
        $ref: "#/definitions/Filter"
      form:
        $ref: "#/definitions/Form"
  CollectionReferenceDescription:
    type: "object"
    required:
    - "collection_name"
    - "params"
    properties:
      properties:
        type: "object"
        additionalProperties:
          $ref: "#/definitions/CollectionReferenceDescriptionProperty"
      collection_name:
        type: "string"
      params:
        $ref: "#/definitions/CollectionReferenceParameters"
  CollectionReferenceDescriptionProperty:
    type: "object"
    properties:
      type:
        type: "string"
        enum:
        - "TEXT"
        - "KEYWORD"
        - "LONG"
        - "INTEGER"
        - "SHORT"
        - "BYTE"
        - "DOUBLE"
        - "FLOAT"
        - "DATE"
        - "BOOLEAN"
        - "BINARY"
        - "INT_RANGE"
        - "FLOAT_RANGE"
        - "LONG_RANGE"
        - "DOUBLE_RANGE"
        - "DATE_RANGE"
        - "OBJECT"
        - "NESTED"
        - "GEO_POINT"
        - "GEO_SHAPE"
        - "IP"
        - "COMPLETION"
        - "TOKEN_COUNT"
        - "MAPPER_MURMUR3"
        - "UNKNOWN"
      format:
        type: "string"
      properties:
        type: "object"
        additionalProperties:
          $ref: "#/definitions/CollectionReferenceDescriptionProperty"
      taggable:
        type: "boolean"
  RangeResponse:
    type: "object"
    properties:
      query_time:
        type: "integer"
        format: "int64"
      total_time:
        type: "integer"
        format: "int64"
      totalnb:
        type: "integer"
        format: "int64"
      min:
        type: "object"
      max:
        type: "object"
  RangeRequest:
    type: "object"
    properties:
      filter:
        $ref: "#/definitions/Filter"
      form:
        $ref: "#/definitions/Form"
      field:
        type: "string"
  Failure:
    type: "object"
    properties:
      id:
        type: "string"
      message:
        type: "string"
      type:
        type: "string"
  UpdateResponse:
    type: "object"
    properties:
      failures:
        type: "array"
        items:
          $ref: "#/definitions/Failure"
      failed:
        type: "integer"
        format: "int64"
      updated:
        type: "integer"
        format: "int64"
      action:
        type: "string"
        enum:
        - "ADD"
        - "REMOVE"
        - "REMOVEALL"
  Tag:
    type: "object"
    properties:
      path:
        type: "string"
      value:
        type: "object"
  TagRequest:
    type: "object"
    properties:
      search:
        $ref: "#/definitions/Search"
      tag:
        $ref: "#/definitions/Tag"
